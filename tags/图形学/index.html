<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: 图形学 - .</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="."><meta name="msapplication-TileImage" content="images/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="."><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="."><meta property="og:url" content="https://olirrrt.github.io/"><meta property="og:site_name" content="."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://olirrrt.github.io/img/og_image.png"><meta property="article:author" content="shugen"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://olirrrt.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://olirrrt.github.io"},"headline":".","image":["https://olirrrt.github.io/img/og_image.png"],"author":{"@type":"Person","name":"shugen"},"publisher":{"@type":"Organization","name":".","logo":{"@type":"ImageObject"}},"description":null}</script><link rel="icon" href="/images/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">.</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Suche" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">图形学</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2023-02-04T16:00:00.000Z" title="2/5/2023, 12:00:00 AM">2023-02-05</time></span><span class="level-item">Aktualisiert vor&nbsp;<time dateTime="2023-02-05T13:00:13.436Z" title="2/5/2023, 9:00:13 PM">2023-02-05</time></span><span class="level-item">19 minutes lesen (Über 2809 Wörter)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/05/Games202-2/">Games202-2 实时环境光照</a></h1><div class="content"><h2 id="1-IBL"><a href="#1-IBL" class="headerlink" title="1.IBL"></a>1.IBL</h2><h3 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h3><p>先简单盘一下数学：</p>
<p><strong>概率密度函数</strong>：其积分值&#x3D;定义域内的概率值，$\int_{-\infin}^{+\infin}f(x)dx&#x3D;1$</p>
<p><strong>期望</strong>：每次可能的结果乘以其结果概率的总和，描述了随机变量的平均值</p>
<p><strong>方差</strong>：随机变量离期望的距离，描述了随机变量的离散程度</p>
<p><strong>大数定律</strong>：当样本数量足够大时，事件发生的<strong>频率</strong>收敛于<strong>概率</strong>。如：为了计算一个国家所有公民的平均身高，可以选择一个<strong>完全随机</strong>（<strong>无偏</strong>）的人口子集，测量他们的身高并对结果求平均，即<strong>用均值近似求解概率</strong>。</p>
<p><strong>蒙特卡罗积分</strong>：$\int_{a}^{b}f(x)dx\approx \frac{1}{N}\sum_{i&#x3D;0}^{N-1}\frac{f(x)}{pdf(x)}$</p>
<p>pdf值更高的样本被选取的可能性更大，即某些样本可能比其他样本具有更高的生成概率，所以要除以<strong>或</strong>乘以pdf以平衡，可以看作是一个<strong>权重</strong>。如：在<strong>单位球体</strong>表面$\Omega$生成N个随机采样，权衡每个样本对结果的贡献并求和。由球体表面积公式，这种情况下、每个样本可能性$p(x_i)&#x3D;\frac{1}{4\pi}$，因此权重$\omega_i&#x3D;\frac{1}{p(x_i)}&#x3D;4\pi$。</p>
<p><strong>低差异序列</strong>：随机样本，但样本分布更均匀</p>
<p><strong>分层采样</strong>：为了降低样本的<strong>方差</strong>，划分单元，每个单元内生成一个随机样本</p>
<p><strong>重要性采样</strong>：已知pdf函数的分布信息生成采样向量。</p>
<h3 id="1-1-Diffuse"><a href="#1-1-Diffuse" class="headerlink" title="1.1 Diffuse"></a>1.1 Diffuse</h3><p>​		我们知道天空盒可以模拟<strong>遥远的</strong>环境光，在早期的实践中，人们会用反射或折射向量采样天空盒纹理作为物体表面颜色，以模拟环境光源对着色的影响，这一技术被称为环境贴图。而随着渲染模型的升级，简单环境贴图显然不能满足需要，基于图像的光照（image based lighting）应运而生。</p>
<p>​		渲染方程（不考虑阴影）：<br>$$<br>L_o(p, \omega_o)&#x3D;\int_{\Omega}(k_d\frac{c}{\pi}+k_s\frac{DFG}{4(\omega_o·n)(\omega_i·n)})L_i(p,\omega_i)n·\omega_id\omega_i<br>$$<br>​		可以拆分为漫反射和镜面两部分，其中漫反射部分为：<br>$$<br>L_o(p, \omega_o)&#x3D;k_d\frac{c}{\pi}\int_{\Omega}L_i(p,\omega_i)n·\omega_id\omega_i<br>$$</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/ibl_hemisphere_sample.png" alt="ibl_hemisphere_sample" style="zoom:50%;" /></center>

<p>​		Lambert的漫反射项是一个常数，因此需要对来自四面八方的环境光计算均值，并用顶点法线查询。对于每一个可能的采样方向n，s在半球表面均匀生成样本求平均。遍历采样方向，可以遍历$\theta$, $\phi$，并转换成方向向量：<br>$$<br>\begin{cases} x&#x3D;rsin\theta cos\phi<br>\ y&#x3D;rsin\theta cos\phi<br>\ z&#x3D;rcos\phi<br>\end{cases}<br>$$<br>​		也可以直接渲染一个位于原点的单位立方体，用归一化后的本地坐标采样。</p>
<p>​		关于样本的生成，可以用蒙特卡洛积分法，这里使用的是黎曼和法。公式2的<strong>离散</strong>版本：<br>$$<br>L_o(p,\phi,\theta)&#x3D;K_d\frac{c}{\pi}\frac{1}{n_1n_2}\sum_{\phi&#x3D;0}^{n_1}\sum_{\theta&#x3D;0}^{n_2}L_i(p,\phi_i,\theta_i)cos(\theta)sin(\theta)d\theta d\phi<br>$$<br>​		其中，立体角公式：$\Omega&#x3D;\frac{dA}{r^2}&#x3D;sin(\theta)d\theta d\phi$，$sin(\theta)$也可以理解成是用来平衡球体两极位置的采样区域（patches )较小而赤道处较大的形状。</p>
<p>​		因为取平均的方法丢失了光照的大部分高频细节，因此纹理分辨率无需太高。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/ibl_irradiance-5522165.png" alt="ibl_irradiance" style="zoom:75%;" /></center>



<h3 id="1-2-Specular"><a href="#1-2-Specular" class="headerlink" title="1.2 Specular"></a>1.2 Specular</h3><p>​		分割求和近似法（split sum approximation）将镜面反射积分拆成两个独立的积分：<br>$$<br>L_o(p, \omega_o)&#x3D;\int_{\Omega}L_i(p,\omega_i)d\omega_i * \int_{\Omega}k_sf_r(\omega_o,\omega_i)n·\omega_id _{\omega_i}<br>$$</p>
<h4 id="1-2-1-预滤波贴图"><a href="#1-2-1-预滤波贴图" class="headerlink" title="1.2.1 预滤波贴图"></a>1.2.1 预滤波贴图</h4><p>​		积分的第一部分，类似漫反射辐照度贴图，但需要将粗糙度纳入考虑范围。不同于lambert平面的均匀反射，glossy物体表面的镜面反射光的形状取决于表面的粗糙。所有可能的反射光线会形成一个specular lobe，围绕着反射向量R，表面越粗糙，反射越分散。因此均匀采样会导致无效采样。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/ibl_specular_lobe.png" style="zoom: 100%;" /></center>

<p>​		GGX重要性采样会根据粗糙度，将微表面的半程向量偏向其宏观反射方向，即向着反射向量“聚集”，使其分布限制在lobe内。根据lobe的<strong>形状</strong>决定样本覆盖的<strong>范围</strong>，在实时端用镜面反射R查询：</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-05 00.03.57.png" alt="2023-02-05 00.03.57" style="zoom:40%;" /></center>

<p>​		理论上来说粗糙度越高，反射越模糊。可以在0到1间取几个锚点，生成对应的贴图，为了方便使用，可生成数个级别的mipmap，并用粗糙度线性插值。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-04 22.38.02.png" alt="2023-02-04 22.38.02" style="zoom:44%;" /></center>



<h4 id="1-2-2-BRDF积分贴图"><a href="#1-2-2-BRDF积分贴图" class="headerlink" title="1.2.2 BRDF积分贴图"></a>1.2.2 BRDF积分贴图</h4><p>​		对于第二部分brdf公式，有3个变量$\omega_i、w_o$、粗糙度和基础反射率$F_0$，为了减少变量数，需要对方程进行一些变形。</p>
<p>​		brdf中的菲涅尔项公式为：<br>$$<br>F(h,\omega_o)&#x3D;F_0+(1-F_0)(1-cos\theta)^5<br>\ \quad\quad\quad\quad\quad\quad\quad\quad &#x3D;F_0(1-(1-cos\theta)^5)+ (1-cos\theta)^5<br>$$</p>
<p>​		第二部分分子分母同乘菲涅尔项：<br>$$<br>L_o(p, \omega_o)&#x3D;\int_{\Omega}\frac{f_r(\omega_o,\omega_i,r)}{F(h,\omega_0)}F(h,\omega_0)n·\omega_id _{\omega_i}<br>$$</p>
<p>​		代入公式6，并将积分拆成两项：<br>$$<br>F_0\int_{\Omega} \frac{f_r(\omega_o,\omega_i,r)}{F(h,\omega_0)}(1-(1-cos\theta)^5)n·\omega_id_{\omega_i} +<br>\int_{\Omega} \frac{f_r(\omega_o,\omega_i,r)}{F(h,\omega_0)}(1-cos\theta)^5n·\omega_id_{\omega_i}<br>$$</p>
<p>​		其中$fr$的分母包含F项，约分后有：<br>$$<br>F_0\int_{\Omega}f_r(\omega_o,\omega_i,r)(1-(1-cos\theta)^5)n·\omega_id_{\omega_i}+\int_{\Omega}f_r(\omega_o,\omega_i,r)(1-cos\theta)^5n·\omega_id_{\omega_i}<br>$$<br>​		$F_0$被提取到积分之外，所以最终只需要计算2个变量$(roughness,\theta)$的可能性组合。因此，我们可以以$co s\theta$为横坐标，粗糙度为纵坐标，R、G通道各存放一个预计算值，得到这样一张查找表：</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-04 20.59.39.png" alt="2023-02-04 20.59.24" style="zoom:75%;" /></center>

<p>​		以上是建立在环境光源无限远的假设上，场景中的各个点所接收到的辐照度是相同的，即无视render point 位置，但在室内这样环境光分布差异较大的场景就会显得不真实，引擎中通常在场景中放置多个反射探针，实时计算时插值。</p>
<h2 id="2-Spherical-Harmonic"><a href="#2-Spherical-Harmonic" class="headerlink" title="2. Spherical Harmonic"></a>2. Spherical Harmonic</h2><p><strong>基函数</strong>：一组简单信号，可以通过线性变换（缩放、相加）生成原函数的<strong>近似</strong>。</p>
<p><strong>投影</strong>：计算出每一个基函数<strong>权重值</strong>的过程。这一标量描述了原函数$f(x)$<strong>有多接近</strong>每一个基函数$B_i(x)$。计算每一个权重的过程，就是在f的定义域上计算$f(x)B_i(x)$的积分：<br>$$<br>c_i&#x3D;\int_{\Omega}f(\omega)B_i(\omega)d\omega<br>$$<br><strong>重建</strong>：类似卷积的过程，用每一个基函数乘以其对应权重、并累加的结果去<strong>近似</strong>原函数。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/Screenshot%202023-02-02%20114949.png" style="zoom:80%;" /><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/Screenshot%202023-02-02%20114712.png" style="zoom:85%;" /><p  style="color:#A9A9A9;">
    投影和重建的过程</p>  </center>

<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/Screenshot%202023-02-02%20114739-1675310084563-6.png"  /> <p  style="color:#A9A9A9;">虚线：原函数；实线：近似函数</p>  </center>

<p><strong>球谐函数</strong>：可以视作三维空间对二维平面fourier变换的<strong>类比</strong>：</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/Screenshot%202023-02-02%20115734.png" style="zoom: 75%;" /> <p  style="color:#A9A9A9;">使用球谐函数的近似，可以看到阶数越高越接近原函数</p>  </center>

<p>​		基函数数量决定还原的精确度，低阶通常会损失高频信息。引擎中常用的是9阶（l &#x3D; 9）球谐函数，工作方法类似一个低通滤波器（只通过低频信息），符合环境-漫反射辐照度的特点；此外，重建的过程将积分降为点乘，在现代GPU架构上极大地提高了效率。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-01-20%2017.55.30.png" style="zoom:50%;" /><div><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-01-20%2017.55.32.png"  /></div><p style="color:#A9A9A9;">
    佬の鄙夷
    </p></center>


<h2 id="3-PRT"><a href="#3-PRT" class="headerlink" title="3.PRT"></a>3.PRT</h2><p>​		如果需要将阴影和brdf项也纳入考虑范围，需要在每点分布生成3张贴图，所需内存过多。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/Screenshot%202023-02-02%20111917.png" style="zoom:67%;" /></center>

<p>​		precomputed radiance transfer则可以看作是上述方案的一个平替。其基本思想是将渲染方程拆成光照和传输两项，分别投影到球谐函数上，并在实时端重建光照。其前提和限制是，假设场景中的物体和视角都保持不变，只有光源变化（可旋转，旋转光源相当于旋转任意一个基函数）。</p>
<h3 id="3-1-Diffuse"><a href="#3-1-Diffuse" class="headerlink" title="3.1 Diffuse"></a>3.1 Diffuse</h3><p>​		光照方程：<br>$$<br>L(o) &#x3D; \int_{\Omega}\textcolor{}{L(i)}\textcolor{}{V(i)\rho(i,o) max(0, n·i)}d_i<br>$$<br>​		由前文，光照函数可以表示为：<br>$$<br>L(i)\approx \sum l_iB_i(i)<br>$$<br>​		代入原式、并交换积分求和顺序，有：<br>$$<br>L(o) \approx \sum l_i \int_{\Omega}\textcolor{Crimson}{B_i(i)}\textcolor{Teal}{V(i)\rho(i,o) max(0, n·i)}d_i<br>$$<br>​		可以看到积分的右半部分也可以视作是基函数 * 一个被投影函数的<strong>形式</strong>，这一函数即传输函数$T(i)$，所以有求传输项系数的方法为：<br>$$<br>T_i\approx \int_{\Omega}B_i(i)V(i)max(0,n	·i)di<br>$$</p>
<p>​		在实时端，将两个系数相乘并累加，近似原光照，从而将积分的过程降为点乘：<br>$$<br>L_o\approx \rho \sum l_i T_i<br>$$</p>
<p>​		对于lambert材质，视线无关，brdf可以提取为常数项，用$\rho$表示。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-04 17.05.58.png"  style="zoom:67%;" /></center>

<h3 id="3-2-Specular"><a href="#3-2-Specular" class="headerlink" title="3.2 Specular"></a>3.2 Specular</h3><p>​		对于glossy材质，brdf不再是常数，而是2个方向的4维函数$\rho(\omega_i,\omega_o)$，需要计算视线和光线的组合。前文已将传输函数投影到入射方向：</p>
<p>$$<br>L(o)\approx \sum L_iT_i(o)<br>$$</p>
<p>​		将投影后的结果，<strong>再一次</strong>投影到出射方向上：<br>$$<br>T_i(o)\approx \sum t_{ij}B_j(o)<br>$$<br>​		代入公式16，最终有：<br>$$<br>L(o)\approx \sum  (\sum l_it_{ij})B_j(o)<br>$$<br>​		即以光照系数乘传输系数矩阵，如下图：</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-04 17.06.38.png"  style="zoom: 67%;" /></center>

<p>​		以上涉及到矩阵运算、其运算复杂度增加；对于特别glossy的物体，低阶球谐的应用性有限。</p>
<p>​		低阶球谐，相比于预滤波辐照度贴图，具有较好地还原低频（漫反射）环境光和（软）阴影、省内存、运算效率高的优点；但是因为毕竟只能还原低频信息，如需表现镜面反射，需要结合其他手段，比如镜面贴图。</p>
<center><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-03 00.12.45.png" style="zoom:35%;" /><div><img src="/2023/02/05/Games202-2/assets/Games202-2.assets/2023-02-03 00.12.57.png"  style="zoom:54%;" /></div><p  style="color:#A9A9A9;">精选弹幕</p>  </center>



<p>🦄️：</p>
<blockquote>
<p>课件：</p>
<p><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_05.pdf">https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_05.pdf</a></p>
<p><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_06.pdf">https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_06.pdf</a></p>
<p>PRT阅读材料：</p>
<p><strong><a target="_blank" rel="noopener" href="https://www.cse.chalmers.se/~uffe/xjobb/Readings/GlobalIllumination/Spherical%20Harmonic%20Lighting%20-%20the%20gritty%20details.pdf">https://www.cse.chalmers.se/~uffe/xjobb/Readings/GlobalIllumination/Spherical%20Harmonic%20Lighting%20-%20the%20gritty%20details.pdf</a></strong></p>
<p><a target="_blank" rel="noopener" href="https://cseweb.ucsd.edu/~ravir/prtsurvey.pdf">https://cseweb.ucsd.edu/~ravir/prtsurvey.pdf</a></p>
<p>IBL:</p>
<p><a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/">https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/</a></p>
<p>第一部分的数学：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/146144853">https://zhuanlan.zhihu.com/p/146144853</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365624460">https://zhuanlan.zhihu.com/p/365624460</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Gepostet vor&nbsp;<time dateTime="2023-02-04T16:00:00.000Z" title="2/5/2023, 12:00:00 AM">2023-02-05</time></span><span class="level-item">Aktualisiert vor&nbsp;<time dateTime="2023-02-05T13:00:13.446Z" title="2/5/2023, 9:00:13 PM">2023-02-05</time></span><span class="level-item">16 minutes lesen (Über 2388 Wörter)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/05/Games202-2_hmw/">Games202 作业2</a></h1><div class="content"><h2 id="0"><a href="#0" class="headerlink" title="0."></a>0.</h2><p>$$<br>L(\omega_o) &#x3D; \int_{\Omega}L(\omega_i)V(\omega_i)\rho(\omega_i,\omega_o) max(0, n·\omega_i)d\omega_i<br>$$</p>
<ul>
<li><p>$L(\omega_i)$：光照函数，这里是采样天空盒；</p>
</li>
<li><p>$T(x)&#x3D;\frac{c}{\pi}V(x,\omega_i)max(0, n·\omega_i)$：传输项函数，$V(x,w_i)$ ：即visibility，指顶点的可见性；$\rho(w_i,w_o) $：是BRDF项，因为只考虑漫反射，所以可以提取为常数项$\frac{c}{\pi}$;</p>
</li>
</ul>
<p>​		需要做的是将$L(\omega_i)$、$T(x)$这两个函数分别<strong>投影</strong>到球谐函数上，即求出其对应系数并存储到矩阵里，在渲染时使用，从而化积分为点乘:<br>$$<br>L&#x3D; \sum_{i&#x3D;0}^{n} L_i T_i<br>$$</p>
<p>​		作业中使用的2个矩阵为：</p>
<ul>
<li><p>m_LightCoeffs ：记录环境光的球谐系数，以rgb的形式存储，是大小 3 x (l + 1) ^ 2的矩阵，每列存储每个环境光系数的rgb值；</p>
</li>
<li><p>m_TransportSHCoeffs： 记录传输项系数，是大小(l + 1) ^ 2 x 顶点数量的矩阵，(i ,  j) 存储第j个顶点的第i个系数。</p>
</li>
</ul>
<h2 id="1-Project"><a href="#1-Project" class="headerlink" title="1. Project :"></a>1. Project :</h2><h3 id="1-1-计算环境光系数"><a href="#1-1-计算环境光系数" class="headerlink" title="1.1 计算环境光系数"></a>1.1 计算环境光系数</h3><p>​		前文已知，投影的过程、即求被投函数*基函数在原函数定义域上积分的过程。对于一个定义在球坐标系上的函数$f(\theta,\phi)$，其积分为：$\int_0^{2\pi}\int_0^{\pi}f(\theta,\phi)sin(\theta)d\theta d\phi$，其中$sin(\theta)$用于平衡两极到赤道的不同单位立体角大小。但是因为蒙特卡洛积分的样本本身是无偏的，每一个样本有相等的概率密度函数$\frac{1}{4\pi}$，因此在这样的情况下，应用$4\pi$代替$sin(\theta)$。所以我们有第i个系数的离散公式为：<br>$$<br>C_i&#x3D;\frac{4\pi}{N}\sum_{i&#x3D;1}^{N}L(x_j)Y_i(x_j)<br>$$<br>​		第一步需要在PrecomputeCubemapSH函数完成对环境光系数的求解，并将返回值以RGB的存储在矩阵m_LightCoeffs里。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> envCoeffs = ProjEnv::<span class="built_in">PrecomputeCubemapSH</span>&lt;SHOrder&gt;(images, width, height, channel);</span><br></pre></td></tr></table></figure>

<p>​		EvalSH 函数即 $Y_l^m(\theta, \varphi)$ , 计算每个单位方向向量对应的基函数<strong>值</strong>：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">EvalSH</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">const</span> Eigen::Vector3d&amp; dir)</span> </span></span><br></pre></td></tr></table></figure>

<p>​		第l阶、第m个系数的对应数组序号可参考源码里的GetIndex函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">GetIndex</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> l * (l + <span class="number">1</span>) + m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		需要注意的是，在作业框架中使用的是黎曼和方法对环境光求积分，权重为立方体贴图的单个纹素所对应在球体上的表面积：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">CalcArea</span><span class="params">(<span class="type">const</span> <span class="type">float</span> &amp;u_, <span class="type">const</span> <span class="type">float</span> &amp;v_, <span class="type">const</span> <span class="type">int</span> &amp;width, <span class="type">const</span> <span class="type">int</span> &amp;height)</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; SHOrder; l++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> m = -l; m &lt;= l; m++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">float</span> sh = sh::<span class="built_in">EvalSH</span>(l, m, dir.<span class="built_in">cast</span>&lt;<span class="type">double</span>&gt;().<span class="built_in">normalized</span>());</span><br><span class="line">		<span class="type">float</span> delta = <span class="built_in">CalcArea</span>(x, y, width, height);</span><br><span class="line">		SHCoeffiecents[l * (l + <span class="number">1</span>) + m] += Le * sh * delta; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-计算传输项系数"><a href="#1-2-计算传输项系数" class="headerlink" title="1.2 计算传输项系数"></a>1.2 计算传输项系数</h3><p>​		每个顶点的传输项系数，实际记录着其可以接收到<strong>多少</strong>直接和间接光照。		</p>
<p>​		shFunc 是传输项函数，是需要<strong>被投影</strong>到球谐函数上的方程，也是需要我们完成的部分，由简到繁依次有unshadowed、shadowed和interreflection三种。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> shCoeff = sh::<span class="built_in">ProjectFunction</span>(SHOrder, shFunc, m_SampleCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; shCoeff-&gt;<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">  	m_TransportSHCoeffs.<span class="built_in">col</span>(i).<span class="built_in">coeffRef</span>(j) = (*shCoeff)[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		投影函数sh::ProjectFunction：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fit the given analytical spherical function to the SH basis functions</span></span><br><span class="line"><span class="comment">// up to @order. This uses Monte Carlo sampling to estimate the underlying</span></span><br><span class="line"><span class="comment">// integral.</span></span><br><span class="line">std::unique_ptr&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">ProjectFunction</span>(</span><br><span class="line">    <span class="type">int</span> order, <span class="type">const</span> SphericalFunction&amp; func, <span class="type">int</span> sample_count);</span><br></pre></td></tr></table></figure>

<p>​		对于前两种情况，翻译公式填到shFunc里就行；因为只考虑漫反射表面，brdf项可以简化为常量，因此传输项为：<br>$$<br>L_{DS}(x)&#x3D;\frac{\rho_x}{\pi} \int_{\Omega}V(w_i) max(0, n_x·w_i)dw_i<br>$$<br>​		因为sh::ProjectFunction中只有积分的右半部分，所以最终系数需要自行除以$\pi$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_Type == Type::Unshadowed)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> here you need to calculate unshadowed transport term of a given direction</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 此处你需要计算给定方向下的unshadowed传输项球谐函数值</span></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">float</span>(<span class="number">0.</span>), wi.<span class="built_in">dot</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> here you need to calculate shadowed transport term of a given direction</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 此处你需要计算给定方向下的shadowed传输项球谐函数值</span></span><br><span class="line">	<span class="type">double</span> H = wi.<span class="built_in">dot</span>(n);</span><br><span class="line">	<span class="keyword">return</span> (H &gt; <span class="number">0</span> &amp;&amp; !(scene-&gt;<span class="built_in">rayIntersect</span>(<span class="built_in">Ray3f</span>(v, wi.<span class="built_in">normalized</span>()))))? H : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		而考虑到光线实际会在表面间互相弹射（interrelection），在这种情况下，其他着色点会成为<strong>次级光源</strong>照亮当前点，因此<strong>一次弹射</strong>的公式：<br>$$<br>L_{DI}(x)&#x3D;L_{DS}+\frac{\rho_x}{\pi} \int_{\Omega}\overline{L}(x’,w_i)(1-V(w_i)) max(0, n_x·w_i)dw_i<br>$$<br>​		在计算出当前顶点的Diffuse Shadow值之后，用蒙特卡洛积分法进行采样；对于每一个样本（射线），如果与场景中的物体有交点，则将交点处的系数值视作次级光源，并计算其<strong>对原顶点</strong>的贡献。而计算交点处的值，则需要用三角形重心线性插值三个顶点的系数即可，这也是公式中$\overline{L}(x’)$的意义。</p>
<p>​		遍历完所有顶点所得的一组<strong>新的</strong>系数（公式的右半部分），正是下一次弹射的初始系数（公式的左半部分）。重复以上步骤，直到光照收敛或到达迭代次数。最后将所有弹射所得系数累加至原传输项系数上。</p>
<blockquote>
<p>Global illumination and radiosity programmers will recognize this is a probabilistic gathering solution, where each point on the model blindly searches for neighbors that can see it and drags in light from the outside world, with the effect that the model is slowly lit by completely solving one lighting point at a time. </p>
</blockquote>
<p>​		因为形式上的相近，可以魔改sh::ProjectFunction函数。注意9个系数分别对应不同的值。 如果考虑物体本身的颜色或场景中实际有多个物体，L项系数也需要计算，这里只计算了T项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_Type == Type::Interreflection)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::vector&lt;Eigen::MatrixXf&gt; <span class="title">transportSHCoeffs</span><span class="params">(m_Bounce, Eigen::MatrixXf(SHCoeffLength, mesh-&gt;getVertexCount()))</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> bounce = <span class="number">0</span>; bounce &lt; m_Bounce; bounce++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;<span class="built_in">getVertexCount</span>(); i++)</span><br><span class="line">				&#123;</span><br><span class="line">					Point3f v = mesh-&gt;<span class="built_in">getVertexPositions</span>().<span class="built_in">col</span>(i);</span><br><span class="line">					<span class="type">const</span> Normal3f &amp;n = mesh-&gt;<span class="built_in">getVertexNormals</span>().<span class="built_in">col</span>(i);</span><br><span class="line">					<span class="keyword">auto</span> shFunc = [&amp;](<span class="type">double</span> phi, <span class="type">double</span> theta) -&gt; std::vector&lt;<span class="type">double</span>&gt;</span><br><span class="line">					&#123;</span><br><span class="line">						Eigen::Array3d d = sh::<span class="built_in">ToVector</span>(phi, theta);</span><br><span class="line">						<span class="keyword">auto</span> wi = <span class="built_in">Vector3f</span>(d.<span class="built_in">x</span>(), d.<span class="built_in">y</span>(), d.<span class="built_in">z</span>()).<span class="built_in">normalized</span>();</span><br><span class="line">						Intersection its;</span><br><span class="line">						<span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">res</span><span class="params">(SHCoeffLength, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">auto</span> H = wi.<span class="built_in">dot</span>(n);</span><br><span class="line">						<span class="keyword">if</span> (H &gt; <span class="number">0</span> &amp;&amp; scene-&gt;<span class="built_in">rayIntersect</span>(<span class="built_in">Ray3f</span>(v, wi), its))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="type">const</span> Vector3f &amp;bary = its.bary;</span><br><span class="line">							<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SHCoeffLength; j++)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">auto</span> its_x = its.tri_index.<span class="built_in">x</span>();</span><br><span class="line">								<span class="keyword">auto</span> its_y = its.tri_index.<span class="built_in">y</span>();</span><br><span class="line">								<span class="keyword">auto</span> its_z = its.tri_index.<span class="built_in">z</span>();</span><br><span class="line">								Vector3f sh = (bounce &gt; <span class="number">0</span>) ? <span class="built_in">Vector3f</span>(transportSHCoeffs[bounce - <span class="number">1</span>].<span class="built_in">col</span>(its_x).<span class="built_in">coeffRef</span>(j), transportSHCoeffs[bounce - <span class="number">1</span>].<span class="built_in">col</span>(its_y).<span class="built_in">coeffRef</span>(j), transportSHCoeffs[bounce - <span class="number">1</span>].<span class="built_in">col</span>(its_z).<span class="built_in">coeffRef</span>(j))</span><br><span class="line">														   : <span class="built_in">Vector3f</span>(m_TransportSHCoeffs.<span class="built_in">col</span>(its_x).<span class="built_in">coeffRef</span>(j), m_TransportSHCoeffs.<span class="built_in">col</span>(its_y).<span class="built_in">coeffRef</span>(j), m_TransportSHCoeffs.<span class="built_in">col</span>(its_z).<span class="built_in">coeffRef</span>(j));</span><br><span class="line"></span><br><span class="line">								<span class="keyword">auto</span> indirectSH = bary.<span class="built_in">dot</span>(sh);</span><br><span class="line">								res[j] = indirectSH * H;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">return</span> res;</span><br><span class="line">					&#125;;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">auto</span> shCoeff = sh::<span class="built_in">ProjectFunctionCustom</span>(SHOrder, shFunc, m_SampleCount);</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; shCoeff-&gt;<span class="built_in">size</span>(); j++)</span><br><span class="line">					&#123;</span><br><span class="line">						transportSHCoeffs[bounce].<span class="built_in">col</span>(i).<span class="built_in">coeffRef</span>(j) = (*shCoeff)[j] / M_PI;</span><br><span class="line">						<span class="comment">// 累加</span></span><br><span class="line">						m_TransportSHCoeffs.<span class="built_in">col</span>(i).<span class="built_in">coeffRef</span>(j) += transportSHCoeffs[bounce].<span class="built_in">col</span>(i).<span class="built_in">coeffRef</span>(j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The assumption here is that illumination doesn’t vary across the model (i.e. point B has exactly the same lighting function as point A). This is the key to SH lighting: Low frequency light sources and very small light source variance across an object. </p>
</blockquote>
<center ><img src="/2023/02/05/Games202-2_hmw/assets/Games202-2_hmw.assets/shadowed.png"  style="zoom:50%;" /> <img src="/2023/02/05/Games202-2_hmw/assets/Games202-2_hmw.assets/inter5.png" style="zoom:50%;" /><p style="color:#A9A9A9;">
  左shadowed，右interreflection = 5
  </p></center>

<p>​		似乎跟作业文档有分歧<del>（算了收敛了就行）</del></p>
<h2 id="2-Reconstruct"><a href="#2-Reconstruct" class="headerlink" title="2. Reconstruct"></a>2. Reconstruct</h2><p>​		直接翻译公式3，在vertex shader里计算每个顶点的颜色，经插值后传递给fragment shader即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">mat3</span> aPrecomputeLT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> uPrecomputeLR;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> uPrecomputeLG;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> uPrecomputeLB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> vColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>) &#123;</span><br><span class="line">    vColor = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">            vColor += aPrecomputeLT[i][j] * <span class="type">vec3</span>(uPrecomputeLR[i][j], uPrecomputeLG[i][j], uPrecomputeLB[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gl_Position</span> = uProjectionMatrix * uViewMatrix * uModelMatrix * <span class="type">vec4</span>(aVertexPosition, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<center ><img src="/2023/02/05/Games202-2_hmw/assets/Games202-2_hmw.assets/prt-sh.png"  style="zoom:50%;" /><img src="/2023/02/05/Games202-2_hmw/assets/Games202-2_hmw.assets/prt-in.png" style="zoom:53.5%;" /><p style="color:#A9A9A9;">
  左shadowed；右interreflection，其self-shadow稍亮
  </p></center>


<h2 id="3-旋转"><a href="#3-旋转" class="headerlink" title="3. 旋转"></a>3. 旋转</h2><p>​		prt中虽然要求场景是静态的，但由于球谐函数具有旋转不变性，所以光源可以旋转。根据文档给出的公式翻译成代码，填到tools.js文件中对应的地方。</p>
<p>​		**glsl的矩阵是列主序，mat[i][j]表示第i列、第j行的值，但是math.size(i, j)、js数组都是行主序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRotationPrecomputeL</span>(<span class="params">precompute_L, rotationMatrix</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> mat3 = <span class="title function_">computeSquareMatrix_3by3</span>(rotationMatrix);</span><br><span class="line">	<span class="keyword">let</span> mat5 = <span class="title function_">computeSquareMatrix_5by5</span>(rotationMatrix);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">let</span> res = math.<span class="title function_">multiply</span>(mat3, [precompute_L[i][<span class="number">1</span>], precompute_L[i][<span class="number">2</span>], precompute_L[i][<span class="number">3</span>]]).<span class="property">_data</span>;</span><br><span class="line">		<span class="keyword">let</span> res5 = math.<span class="title function_">multiply</span>(mat5, [precompute_L[i][<span class="number">4</span>], precompute_L[i][<span class="number">5</span>], precompute_L[i][<span class="number">6</span>], precompute_L[i][<span class="number">6</span>], precompute_L[i][<span class="number">8</span>]]).<span class="property">_data</span>;</span><br><span class="line">		result.<span class="title function_">push</span>([precompute_L[i][<span class="number">0</span>], res[<span class="number">0</span>], res[<span class="number">1</span>], res[<span class="number">2</span>], res5[<span class="number">0</span>], res5[<span class="number">1</span>], res5[<span class="number">2</span>], res5[<span class="number">3</span>], res5[<span class="number">4</span>]]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computeSquareMatrix_3by3</span>(<span class="params">rotationMatrix</span>) &#123; <span class="comment">// 计算方阵SA(-1) 3*3 </span></span><br><span class="line">	<span class="comment">// 1、pick ni - &#123;ni&#125;</span></span><br><span class="line">	<span class="comment">// 对于第 l 层 band，选取 2l + 1 个 normal vector n</span></span><br><span class="line">	<span class="keyword">let</span> n1 = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; <span class="keyword">let</span> n2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]; <span class="keyword">let</span> n3 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">	<span class="keyword">let</span> normals = [n1, n2, n3];</span><br><span class="line">	<span class="keyword">let</span> A = math.<span class="title function_">zeros</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">let</span> S = math.<span class="title function_">zeros</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">let</span> A_inverse = math.<span class="title function_">zeros</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="comment">//	let rotationMatrix_trans = math.transpose(mat4Matrix2mathMatrix(rotationMatrix)); // 数列转换为math.mat</span></span><br><span class="line">	<span class="keyword">let</span> rotationMatrix_trans = (<span class="title function_">mat4Matrix2mathMatrix</span>(rotationMatrix)); <span class="comment">// 数列转换为math.mat</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、&#123;P(ni)&#125; - A  A_inverse</span></span><br><span class="line">	<span class="comment">// 计算(2l + 1)个n各自在球谐上的投影，每个有(2l + 1)个系数，构成(2l + 1) * (2l + 1)的矩阵A，并求其逆矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">let</span> proj = <span class="title class_">SHEval3</span>(normals[i][<span class="number">0</span>], normals[i][<span class="number">1</span>], normals[i][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">			A.<span class="title function_">set</span>([j - <span class="number">1</span>, i], proj[j]);<span class="comment">// i行j列</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A_inverse = math.<span class="title function_">inv</span>(A);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3、用 R 旋转 ni - &#123;R(ni)&#125;</span></span><br><span class="line">	<span class="comment">// 4、R(ni) SH投影 - S</span></span><br><span class="line">	<span class="comment">// 用输入的旋转矩阵旋转ni，并将结果投影，类似步骤2，得到(2l + 1) * (2l + 1)的矩阵S</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="comment">//let vec = math.matrix([normals[i][0], normals[i][1], normals[i][2], 0]); // col vector  </span></span><br><span class="line">		<span class="comment">//let n = math.multiply(rotationMatrix_trans, vec)._data;// (4 * 4) * (4 * 1) 第一个列数等于第二个行数</span></span><br><span class="line">		<span class="keyword">let</span> n = vec4.<span class="title function_">create</span>();</span><br><span class="line">		vec4.<span class="title function_">transformMat4</span>(n, normals[i], rotationMatrix);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">let</span> proj = <span class="title class_">SHEval3</span>(n[<span class="number">0</span>], n[<span class="number">1</span>], n[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">			S.<span class="title function_">set</span>([j - <span class="number">1</span>, i], proj[j]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5、S*A_inverse</span></span><br><span class="line">	<span class="keyword">return</span> math.<span class="title function_">multiply</span>(S, A_inverse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center><img src="/2023/02/05/Games202-2_hmw/assets/Games202-2_hmw.assets/127.0.0.1_5501 (1).gif"  style="zoom:80%;" /></center>





<p>🔧工具：</p>
<p><strong>Glsl:</strong>  <a target="_blank" rel="noopener" href="https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.30.pdf#page=35">https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.30.pdf#page=35</a></p>
<p><strong>Webgl:</strong>  <a target="_blank" rel="noopener" href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html</a></p>
<p>ide debug:  <a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/cpp/launch-json-reference">https://code.visualstudio.com/docs/cpp/launch-json-reference</a></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.png" alt="shugen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">shugen</p><p class="is-size-6 is-block">zzz</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShangHai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Seiten</p><a href="/archives"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Kategorien</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tag</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/olirrrt"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://trilozzz.lofter.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/Trilo67899622"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Letzte Einträge</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-04T16:00:00.000Z">2023-02-05</time></p><p class="title"><a href="/2023/02/05/Games202-2/">Games202-2 实时环境光照</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-04T16:00:00.000Z">2023-02-05</time></p><p class="title"><a href="/2023/02/05/Games202-2_hmw/">Games202 作业2</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-03T16:00:00.000Z">2023-02-04</time></p><p class="title"><a href="/2023/02/04/test/">人生贵在折腾(≧▽≦)</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archive</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">February 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"><span class="tag">图形学</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Abonnieren Sie Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Abonnieren"></div></div></form></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Abonnieren"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">.</a><p class="is-size-7"><span>&copy; 2023 shugen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en-us");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Zurück nach oben" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Diese Website verwendet Cookies, um Ihre Erfahrung zu verbessern.",
          dismiss: "Verstanden!",
          allow: "Cookies zulassen",
          deny: "Ablehnen",
          link: "Mehr erfahren",
          policy: "Cookie-Richtlinie",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Tippen Sie etwas..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Tippen Sie etwas...","untitled":"(Ohne Titel)","posts":"Seiten","pages":"Pages","categories":"Kategorien","tags":"Tags"});
        });</script></body></html>