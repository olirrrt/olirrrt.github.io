{"posts":[{"title":"Games202-2 å®æ—¶ç¯å¢ƒå…‰ç…§","text":"1.IBL1.0å…ˆç®€å•ç›˜ä¸€ä¸‹æ•°å­¦ï¼š æ¦‚ç‡å¯†åº¦å‡½æ•°ï¼šå…¶ç§¯åˆ†å€¼=å®šä¹‰åŸŸå†…çš„æ¦‚ç‡å€¼ï¼Œ$\\int_{-\\infin}^{+\\infin}f(x)dx=1$ æœŸæœ›ï¼šæ¯æ¬¡å¯èƒ½çš„ç»“æœä¹˜ä»¥å…¶ç»“æœæ¦‚ç‡çš„æ€»å’Œï¼Œæè¿°äº†éšæœºå˜é‡çš„å¹³å‡å€¼ æ–¹å·®ï¼šéšæœºå˜é‡ç¦»æœŸæœ›çš„è·ç¦»ï¼Œæè¿°äº†éšæœºå˜é‡çš„ç¦»æ•£ç¨‹åº¦ å¤§æ•°å®šå¾‹ï¼šå½“æ ·æœ¬æ•°é‡è¶³å¤Ÿå¤§æ—¶ï¼Œäº‹ä»¶å‘ç”Ÿçš„é¢‘ç‡æ”¶æ•›äºæ¦‚ç‡ã€‚å¦‚ï¼šä¸ºäº†è®¡ç®—ä¸€ä¸ªå›½å®¶æ‰€æœ‰å…¬æ°‘çš„å¹³å‡èº«é«˜ï¼Œå¯ä»¥é€‰æ‹©ä¸€ä¸ªå®Œå…¨éšæœºï¼ˆæ— åï¼‰çš„äººå£å­é›†ï¼Œæµ‹é‡ä»–ä»¬çš„èº«é«˜å¹¶å¯¹ç»“æœæ±‚å¹³å‡ï¼Œå³ç”¨å‡å€¼è¿‘ä¼¼æ±‚è§£æ¦‚ç‡ã€‚ è’™ç‰¹å¡ç½—ç§¯åˆ†ï¼š$\\int_{a}^{b}f(x)dx\\approx \\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{f(x)}{pdf(x)}$ pdfå€¼æ›´é«˜çš„æ ·æœ¬è¢«é€‰å–çš„å¯èƒ½æ€§æ›´å¤§ï¼Œå³æŸäº›æ ·æœ¬å¯èƒ½æ¯”å…¶ä»–æ ·æœ¬å…·æœ‰æ›´é«˜çš„ç”Ÿæˆæ¦‚ç‡ï¼Œæ‰€ä»¥è¦é™¤ä»¥æˆ–ä¹˜ä»¥pdfä»¥å¹³è¡¡ï¼Œå¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªæƒé‡ã€‚å¦‚ï¼šåœ¨å•ä½çƒä½“è¡¨é¢$\\Omega$ç”ŸæˆNä¸ªéšæœºé‡‡æ ·ï¼Œæƒè¡¡æ¯ä¸ªæ ·æœ¬å¯¹ç»“æœçš„è´¡çŒ®å¹¶æ±‚å’Œã€‚ç”±çƒä½“è¡¨é¢ç§¯å…¬å¼ï¼Œè¿™ç§æƒ…å†µä¸‹ã€æ¯ä¸ªæ ·æœ¬å¯èƒ½æ€§$p(x_i)=\\frac{1}{4\\pi}$ï¼Œå› æ­¤æƒé‡$\\omega_i=\\frac{1}{p(x_i)}=4\\pi$ã€‚ ä½å·®å¼‚åºåˆ—ï¼šéšæœºæ ·æœ¬ï¼Œä½†æ ·æœ¬åˆ†å¸ƒæ›´å‡åŒ€ åˆ†å±‚é‡‡æ ·ï¼šä¸ºäº†é™ä½æ ·æœ¬çš„æ–¹å·®ï¼Œåˆ’åˆ†å•å…ƒï¼Œæ¯ä¸ªå•å…ƒå†…ç”Ÿæˆä¸€ä¸ªéšæœºæ ·æœ¬ é‡è¦æ€§é‡‡æ ·ï¼šå·²çŸ¥pdfå‡½æ•°çš„åˆ†å¸ƒä¿¡æ¯ç”Ÿæˆé‡‡æ ·å‘é‡ã€‚ 1.1 Diffuseâ€‹ æˆ‘ä»¬çŸ¥é“å¤©ç©ºç›’å¯ä»¥æ¨¡æ‹Ÿé¥è¿œçš„ç¯å¢ƒå…‰ï¼Œåœ¨æ—©æœŸçš„å®è·µä¸­ï¼Œäººä»¬ä¼šç”¨åå°„æˆ–æŠ˜å°„å‘é‡é‡‡æ ·å¤©ç©ºç›’çº¹ç†ä½œä¸ºç‰©ä½“è¡¨é¢é¢œè‰²ï¼Œä»¥æ¨¡æ‹Ÿç¯å¢ƒå…‰æºå¯¹ç€è‰²çš„å½±å“ï¼Œè¿™ä¸€æŠ€æœ¯è¢«ç§°ä¸ºç¯å¢ƒè´´å›¾ã€‚è€Œéšç€æ¸²æŸ“æ¨¡å‹çš„å‡çº§ï¼Œç®€å•ç¯å¢ƒè´´å›¾æ˜¾ç„¶ä¸èƒ½æ»¡è¶³éœ€è¦ï¼ŒåŸºäºå›¾åƒçš„å…‰ç…§ï¼ˆimage based lightingï¼‰åº”è¿è€Œç”Ÿã€‚ â€‹ æ¸²æŸ“æ–¹ç¨‹ï¼ˆä¸è€ƒè™‘é˜´å½±ï¼‰ï¼š$$L_o(p, \\omega_o)=\\int_{\\Omega}(k_d\\frac{c}{\\pi}+k_s\\frac{DFG}{4(\\omega_oÂ·n)(\\omega_iÂ·n)})L_i(p,\\omega_i)nÂ·\\omega_id\\omega_i$$â€‹ å¯ä»¥æ‹†åˆ†ä¸ºæ¼«åå°„å’Œé•œé¢ä¸¤éƒ¨åˆ†ï¼Œå…¶ä¸­æ¼«åå°„éƒ¨åˆ†ä¸ºï¼š$$L_o(p, \\omega_o)=k_d\\frac{c}{\\pi}\\int_{\\Omega}L_i(p,\\omega_i)nÂ·\\omega_id\\omega_i$$ â€‹ Lambertçš„æ¼«åå°„é¡¹æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œå› æ­¤éœ€è¦å¯¹æ¥è‡ªå››é¢å…«æ–¹çš„ç¯å¢ƒå…‰è®¡ç®—å‡å€¼ï¼Œå¹¶ç”¨é¡¶ç‚¹æ³•çº¿æŸ¥è¯¢ã€‚å¯¹äºæ¯ä¸€ä¸ªå¯èƒ½çš„é‡‡æ ·æ–¹å‘nï¼Œsåœ¨åŠçƒè¡¨é¢å‡åŒ€ç”Ÿæˆæ ·æœ¬æ±‚å¹³å‡ã€‚éå†é‡‡æ ·æ–¹å‘ï¼Œå¯ä»¥éå†$\\theta$, $\\phi$ï¼Œå¹¶è½¬æ¢æˆæ–¹å‘å‘é‡ï¼š$$\\begin{cases} x=rsin\\theta cos\\phi\\ y=rsin\\theta cos\\phi\\ z=rcos\\phi\\end{cases}$$â€‹ ä¹Ÿå¯ä»¥ç›´æ¥æ¸²æŸ“ä¸€ä¸ªä½äºåŸç‚¹çš„å•ä½ç«‹æ–¹ä½“ï¼Œç”¨å½’ä¸€åŒ–åçš„æœ¬åœ°åæ ‡é‡‡æ ·ã€‚ â€‹ å…³äºæ ·æœ¬çš„ç”Ÿæˆï¼Œå¯ä»¥ç”¨è’™ç‰¹å¡æ´›ç§¯åˆ†æ³•ï¼Œè¿™é‡Œä½¿ç”¨çš„æ˜¯é»æ›¼å’Œæ³•ã€‚å…¬å¼2çš„ç¦»æ•£ç‰ˆæœ¬ï¼š$$L_o(p,\\phi,\\theta)=K_d\\frac{c}{\\pi}\\frac{1}{n_1n_2}\\sum_{\\phi=0}^{n_1}\\sum_{\\theta=0}^{n_2}L_i(p,\\phi_i,\\theta_i)cos(\\theta)sin(\\theta)d\\theta d\\phi$$â€‹ å…¶ä¸­ï¼Œç«‹ä½“è§’å…¬å¼ï¼š$\\Omega=\\frac{dA}{r^2}=sin(\\theta)d\\theta d\\phi$ï¼Œ$sin(\\theta)$ä¹Ÿå¯ä»¥ç†è§£æˆæ˜¯ç”¨æ¥å¹³è¡¡çƒä½“ä¸¤æä½ç½®çš„é‡‡æ ·åŒºåŸŸï¼ˆpatches )è¾ƒå°è€Œèµ¤é“å¤„è¾ƒå¤§çš„å½¢çŠ¶ã€‚ â€‹ å› ä¸ºå–å¹³å‡çš„æ–¹æ³•ä¸¢å¤±äº†å…‰ç…§çš„å¤§éƒ¨åˆ†é«˜é¢‘ç»†èŠ‚ï¼Œå› æ­¤çº¹ç†åˆ†è¾¨ç‡æ— éœ€å¤ªé«˜ã€‚ 1.2 Specularâ€‹ åˆ†å‰²æ±‚å’Œè¿‘ä¼¼æ³•ï¼ˆsplit sum approximationï¼‰å°†é•œé¢åå°„ç§¯åˆ†æ‹†æˆä¸¤ä¸ªç‹¬ç«‹çš„ç§¯åˆ†ï¼š$$L_o(p, \\omega_o)=\\int_{\\Omega}L_i(p,\\omega_i)d\\omega_i * \\int_{\\Omega}k_sf_r(\\omega_o,\\omega_i)nÂ·\\omega_id _{\\omega_i}$$ 1.2.1 é¢„æ»¤æ³¢è´´å›¾â€‹ ç§¯åˆ†çš„ç¬¬ä¸€éƒ¨åˆ†ï¼Œç±»ä¼¼æ¼«åå°„è¾ç…§åº¦è´´å›¾ï¼Œä½†éœ€è¦å°†ç²—ç³™åº¦çº³å…¥è€ƒè™‘èŒƒå›´ã€‚ä¸åŒäºlambertå¹³é¢çš„å‡åŒ€åå°„ï¼Œglossyç‰©ä½“è¡¨é¢çš„é•œé¢åå°„å…‰çš„å½¢çŠ¶å–å†³äºè¡¨é¢çš„ç²—ç³™ã€‚æ‰€æœ‰å¯èƒ½çš„åå°„å…‰çº¿ä¼šå½¢æˆä¸€ä¸ªspecular lobeï¼Œå›´ç»•ç€åå°„å‘é‡Rï¼Œè¡¨é¢è¶Šç²—ç³™ï¼Œåå°„è¶Šåˆ†æ•£ã€‚å› æ­¤å‡åŒ€é‡‡æ ·ä¼šå¯¼è‡´æ— æ•ˆé‡‡æ ·ã€‚ â€‹ GGXé‡è¦æ€§é‡‡æ ·ä¼šæ ¹æ®ç²—ç³™åº¦ï¼Œå°†å¾®è¡¨é¢çš„åŠç¨‹å‘é‡åå‘å…¶å®è§‚åå°„æ–¹å‘ï¼Œå³å‘ç€åå°„å‘é‡â€œèšé›†â€ï¼Œä½¿å…¶åˆ†å¸ƒé™åˆ¶åœ¨lobeå†…ã€‚æ ¹æ®lobeçš„å½¢çŠ¶å†³å®šæ ·æœ¬è¦†ç›–çš„èŒƒå›´ï¼Œåœ¨å®æ—¶ç«¯ç”¨é•œé¢åå°„RæŸ¥è¯¢ï¼š â€‹ ç†è®ºä¸Šæ¥è¯´ç²—ç³™åº¦è¶Šé«˜ï¼Œåå°„è¶Šæ¨¡ç³Šã€‚å¯ä»¥åœ¨0åˆ°1é—´å–å‡ ä¸ªé”šç‚¹ï¼Œç”Ÿæˆå¯¹åº”çš„è´´å›¾ï¼Œä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ï¼Œå¯ç”Ÿæˆæ•°ä¸ªçº§åˆ«çš„mipmapï¼Œå¹¶ç”¨ç²—ç³™åº¦çº¿æ€§æ’å€¼ã€‚ 1.2.2 BRDFç§¯åˆ†è´´å›¾â€‹ å¯¹äºç¬¬äºŒéƒ¨åˆ†brdfå…¬å¼ï¼Œæœ‰3ä¸ªå˜é‡$\\omega_iã€w_o$ã€ç²—ç³™åº¦å’ŒåŸºç¡€åå°„ç‡$F_0$ï¼Œä¸ºäº†å‡å°‘å˜é‡æ•°ï¼Œéœ€è¦å¯¹æ–¹ç¨‹è¿›è¡Œä¸€äº›å˜å½¢ã€‚ â€‹ brdfä¸­çš„è²æ¶…å°”é¡¹å…¬å¼ä¸ºï¼š$$F(h,\\omega_o)=F_0+(1-F_0)(1-cos\\theta)^5\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad =F_0(1-(1-cos\\theta)^5)+ (1-cos\\theta)^5$$ â€‹ ç¬¬äºŒéƒ¨åˆ†åˆ†å­åˆ†æ¯åŒä¹˜è²æ¶…å°”é¡¹ï¼š$$L_o(p, \\omega_o)=\\int_{\\Omega}\\frac{f_r(\\omega_o,\\omega_i,r)}{F(h,\\omega_0)}F(h,\\omega_0)nÂ·\\omega_id _{\\omega_i}$$ â€‹ ä»£å…¥å…¬å¼6ï¼Œå¹¶å°†ç§¯åˆ†æ‹†æˆä¸¤é¡¹ï¼š$$F_0\\int_{\\Omega} \\frac{f_r(\\omega_o,\\omega_i,r)}{F(h,\\omega_0)}(1-(1-cos\\theta)^5)nÂ·\\omega_id_{\\omega_i} +\\int_{\\Omega} \\frac{f_r(\\omega_o,\\omega_i,r)}{F(h,\\omega_0)}(1-cos\\theta)^5nÂ·\\omega_id_{\\omega_i}$$ â€‹ å…¶ä¸­$fr$çš„åˆ†æ¯åŒ…å«Fé¡¹ï¼Œçº¦åˆ†åæœ‰ï¼š$$F_0\\int_{\\Omega}f_r(\\omega_o,\\omega_i,r)(1-(1-cos\\theta)^5)nÂ·\\omega_id_{\\omega_i}+\\int_{\\Omega}f_r(\\omega_o,\\omega_i,r)(1-cos\\theta)^5nÂ·\\omega_id_{\\omega_i}$$â€‹ $F_0$è¢«æå–åˆ°ç§¯åˆ†ä¹‹å¤–ï¼Œæ‰€ä»¥æœ€ç»ˆåªéœ€è¦è®¡ç®—2ä¸ªå˜é‡$(roughness,\\theta)$çš„å¯èƒ½æ€§ç»„åˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥$co s\\theta$ä¸ºæ¨ªåæ ‡ï¼Œç²—ç³™åº¦ä¸ºçºµåæ ‡ï¼ŒRã€Gé€šé“å„å­˜æ”¾ä¸€ä¸ªé¢„è®¡ç®—å€¼ï¼Œå¾—åˆ°è¿™æ ·ä¸€å¼ æŸ¥æ‰¾è¡¨ï¼š â€‹ ä»¥ä¸Šæ˜¯å»ºç«‹åœ¨ç¯å¢ƒå…‰æºæ— é™è¿œçš„å‡è®¾ä¸Šï¼Œåœºæ™¯ä¸­çš„å„ä¸ªç‚¹æ‰€æ¥æ”¶åˆ°çš„è¾ç…§åº¦æ˜¯ç›¸åŒçš„ï¼Œå³æ— è§†render point ä½ç½®ï¼Œä½†åœ¨å®¤å†…è¿™æ ·ç¯å¢ƒå…‰åˆ†å¸ƒå·®å¼‚è¾ƒå¤§çš„åœºæ™¯å°±ä¼šæ˜¾å¾—ä¸çœŸå®ï¼Œå¼•æ“ä¸­é€šå¸¸åœ¨åœºæ™¯ä¸­æ”¾ç½®å¤šä¸ªåå°„æ¢é’ˆï¼Œå®æ—¶è®¡ç®—æ—¶æ’å€¼ã€‚ 2. Spherical HarmonicåŸºå‡½æ•°ï¼šä¸€ç»„ç®€å•ä¿¡å·ï¼Œå¯ä»¥é€šè¿‡çº¿æ€§å˜æ¢ï¼ˆç¼©æ”¾ã€ç›¸åŠ ï¼‰ç”ŸæˆåŸå‡½æ•°çš„è¿‘ä¼¼ã€‚ æŠ•å½±ï¼šè®¡ç®—å‡ºæ¯ä¸€ä¸ªåŸºå‡½æ•°æƒé‡å€¼çš„è¿‡ç¨‹ã€‚è¿™ä¸€æ ‡é‡æè¿°äº†åŸå‡½æ•°$f(x)$æœ‰å¤šæ¥è¿‘æ¯ä¸€ä¸ªåŸºå‡½æ•°$B_i(x)$ã€‚è®¡ç®—æ¯ä¸€ä¸ªæƒé‡çš„è¿‡ç¨‹ï¼Œå°±æ˜¯åœ¨fçš„å®šä¹‰åŸŸä¸Šè®¡ç®—$f(x)B_i(x)$çš„ç§¯åˆ†ï¼š$$c_i=\\int_{\\Omega}f(\\omega)B_i(\\omega)d\\omega$$é‡å»ºï¼šç±»ä¼¼å·ç§¯çš„è¿‡ç¨‹ï¼Œç”¨æ¯ä¸€ä¸ªåŸºå‡½æ•°ä¹˜ä»¥å…¶å¯¹åº”æƒé‡ã€å¹¶ç´¯åŠ çš„ç»“æœå»è¿‘ä¼¼åŸå‡½æ•°ã€‚ æŠ•å½±å’Œé‡å»ºçš„è¿‡ç¨‹ è™šçº¿ï¼šåŸå‡½æ•°ï¼›å®çº¿ï¼šè¿‘ä¼¼å‡½æ•° çƒè°å‡½æ•°ï¼šå¯ä»¥è§†ä½œä¸‰ç»´ç©ºé—´å¯¹äºŒç»´å¹³é¢fourierå˜æ¢çš„ç±»æ¯”ï¼š ä½¿ç”¨çƒè°å‡½æ•°çš„è¿‘ä¼¼ï¼Œå¯ä»¥çœ‹åˆ°é˜¶æ•°è¶Šé«˜è¶Šæ¥è¿‘åŸå‡½æ•° â€‹ åŸºå‡½æ•°æ•°é‡å†³å®šè¿˜åŸçš„ç²¾ç¡®åº¦ï¼Œä½é˜¶é€šå¸¸ä¼šæŸå¤±é«˜é¢‘ä¿¡æ¯ã€‚å¼•æ“ä¸­å¸¸ç”¨çš„æ˜¯9é˜¶ï¼ˆl = 9ï¼‰çƒè°å‡½æ•°ï¼Œå·¥ä½œæ–¹æ³•ç±»ä¼¼ä¸€ä¸ªä½é€šæ»¤æ³¢å™¨ï¼ˆåªé€šè¿‡ä½é¢‘ä¿¡æ¯ï¼‰ï¼Œç¬¦åˆç¯å¢ƒ-æ¼«åå°„è¾ç…§åº¦çš„ç‰¹ç‚¹ï¼›æ­¤å¤–ï¼Œé‡å»ºçš„è¿‡ç¨‹å°†ç§¯åˆ†é™ä¸ºç‚¹ä¹˜ï¼Œåœ¨ç°ä»£GPUæ¶æ„ä¸Šæå¤§åœ°æé«˜äº†æ•ˆç‡ã€‚ ä½¬ã®é„™å¤· 3.PRTâ€‹ å¦‚æœéœ€è¦å°†é˜´å½±å’Œbrdfé¡¹ä¹Ÿçº³å…¥è€ƒè™‘èŒƒå›´ï¼Œéœ€è¦åœ¨æ¯ç‚¹åˆ†å¸ƒç”Ÿæˆ3å¼ è´´å›¾ï¼Œæ‰€éœ€å†…å­˜è¿‡å¤šã€‚ â€‹ precomputed radiance transferåˆ™å¯ä»¥çœ‹ä½œæ˜¯ä¸Šè¿°æ–¹æ¡ˆçš„ä¸€ä¸ªå¹³æ›¿ã€‚å…¶åŸºæœ¬æ€æƒ³æ˜¯å°†æ¸²æŸ“æ–¹ç¨‹æ‹†æˆå…‰ç…§å’Œä¼ è¾“ä¸¤é¡¹ï¼Œåˆ†åˆ«æŠ•å½±åˆ°çƒè°å‡½æ•°ä¸Šï¼Œå¹¶åœ¨å®æ—¶ç«¯é‡å»ºå…‰ç…§ã€‚å…¶å‰æå’Œé™åˆ¶æ˜¯ï¼Œå‡è®¾åœºæ™¯ä¸­çš„ç‰©ä½“å’Œè§†è§’éƒ½ä¿æŒä¸å˜ï¼Œåªæœ‰å…‰æºå˜åŒ–ï¼ˆå¯æ—‹è½¬ï¼Œæ—‹è½¬å…‰æºç›¸å½“äºæ—‹è½¬ä»»æ„ä¸€ä¸ªåŸºå‡½æ•°ï¼‰ã€‚ 3.1 Diffuseâ€‹ å…‰ç…§æ–¹ç¨‹ï¼š$$L(o) = \\int_{\\Omega}\\textcolor{}{L(i)}\\textcolor{}{V(i)\\rho(i,o) max(0, nÂ·i)}d_i$$â€‹ ç”±å‰æ–‡ï¼Œå…‰ç…§å‡½æ•°å¯ä»¥è¡¨ç¤ºä¸ºï¼š$$L(i)\\approx \\sum l_iB_i(i)$$â€‹ ä»£å…¥åŸå¼ã€å¹¶äº¤æ¢ç§¯åˆ†æ±‚å’Œé¡ºåºï¼Œæœ‰ï¼š$$L(o) \\approx \\sum l_i \\int_{\\Omega}\\textcolor{Crimson}{B_i(i)}\\textcolor{Teal}{V(i)\\rho(i,o) max(0, nÂ·i)}d_i$$â€‹ å¯ä»¥çœ‹åˆ°ç§¯åˆ†çš„å³åŠéƒ¨åˆ†ä¹Ÿå¯ä»¥è§†ä½œæ˜¯åŸºå‡½æ•° * ä¸€ä¸ªè¢«æŠ•å½±å‡½æ•°çš„å½¢å¼ï¼Œè¿™ä¸€å‡½æ•°å³ä¼ è¾“å‡½æ•°$T(i)$ï¼Œæ‰€ä»¥æœ‰æ±‚ä¼ è¾“é¡¹ç³»æ•°çš„æ–¹æ³•ä¸ºï¼š$$T_i\\approx \\int_{\\Omega}B_i(i)V(i)max(0,n Â·i)di$$ â€‹ åœ¨å®æ—¶ç«¯ï¼Œå°†ä¸¤ä¸ªç³»æ•°ç›¸ä¹˜å¹¶ç´¯åŠ ï¼Œè¿‘ä¼¼åŸå…‰ç…§ï¼Œä»è€Œå°†ç§¯åˆ†çš„è¿‡ç¨‹é™ä¸ºç‚¹ä¹˜ï¼š$$L_o\\approx \\rho \\sum l_i T_i$$ â€‹ å¯¹äºlambertæè´¨ï¼Œè§†çº¿æ— å…³ï¼Œbrdfå¯ä»¥æå–ä¸ºå¸¸æ•°é¡¹ï¼Œç”¨$\\rho$è¡¨ç¤ºã€‚ 3.2 Specularâ€‹ å¯¹äºglossyæè´¨ï¼Œbrdfä¸å†æ˜¯å¸¸æ•°ï¼Œè€Œæ˜¯2ä¸ªæ–¹å‘çš„4ç»´å‡½æ•°$\\rho(\\omega_i,\\omega_o)$ï¼Œéœ€è¦è®¡ç®—è§†çº¿å’Œå…‰çº¿çš„ç»„åˆã€‚å‰æ–‡å·²å°†ä¼ è¾“å‡½æ•°æŠ•å½±åˆ°å…¥å°„æ–¹å‘ï¼š $$L(o)\\approx \\sum L_iT_i(o)$$ â€‹ å°†æŠ•å½±åçš„ç»“æœï¼Œå†ä¸€æ¬¡æŠ•å½±åˆ°å‡ºå°„æ–¹å‘ä¸Šï¼š$$T_i(o)\\approx \\sum t_{ij}B_j(o)$$â€‹ ä»£å…¥å…¬å¼16ï¼Œæœ€ç»ˆæœ‰ï¼š$$L(o)\\approx \\sum (\\sum l_it_{ij})B_j(o)$$â€‹ å³ä»¥å…‰ç…§ç³»æ•°ä¹˜ä¼ è¾“ç³»æ•°çŸ©é˜µï¼Œå¦‚ä¸‹å›¾ï¼š â€‹ ä»¥ä¸Šæ¶‰åŠåˆ°çŸ©é˜µè¿ç®—ã€å…¶è¿ç®—å¤æ‚åº¦å¢åŠ ï¼›å¯¹äºç‰¹åˆ«glossyçš„ç‰©ä½“ï¼Œä½é˜¶çƒè°çš„åº”ç”¨æ€§æœ‰é™ã€‚ â€‹ ä½é˜¶çƒè°ï¼Œç›¸æ¯”äºé¢„æ»¤æ³¢è¾ç…§åº¦è´´å›¾ï¼Œå…·æœ‰è¾ƒå¥½åœ°è¿˜åŸä½é¢‘ï¼ˆæ¼«åå°„ï¼‰ç¯å¢ƒå…‰å’Œï¼ˆè½¯ï¼‰é˜´å½±ã€çœå†…å­˜ã€è¿ç®—æ•ˆç‡é«˜çš„ä¼˜ç‚¹ï¼›ä½†æ˜¯å› ä¸ºæ¯•ç«Ÿåªèƒ½è¿˜åŸä½é¢‘ä¿¡æ¯ï¼Œå¦‚éœ€è¡¨ç°é•œé¢åå°„ï¼Œéœ€è¦ç»“åˆå…¶ä»–æ‰‹æ®µï¼Œæ¯”å¦‚é•œé¢è´´å›¾ã€‚ ç²¾é€‰å¼¹å¹• ğŸ¦„ï¸ï¼š è¯¾ä»¶ï¼š https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_05.pdf https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_06.pdf PRTé˜…è¯»ææ–™ï¼š https://www.cse.chalmers.se/~uffe/xjobb/Readings/GlobalIllumination/Spherical%20Harmonic%20Lighting%20-%20the%20gritty%20details.pdf https://cseweb.ucsd.edu/~ravir/prtsurvey.pdf IBL: https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/ ç¬¬ä¸€éƒ¨åˆ†çš„æ•°å­¦ï¼š https://zhuanlan.zhihu.com/p/146144853 https://zhuanlan.zhihu.com/p/365624460","link":"/2023/02/05/Games202-2/"},{"title":"Games202 ä½œä¸š2","text":"0.$$L(\\omega_o) = \\int_{\\Omega}L(\\omega_i)V(\\omega_i)\\rho(\\omega_i,\\omega_o) max(0, nÂ·\\omega_i)d\\omega_i$$ $L(\\omega_i)$ï¼šå…‰ç…§å‡½æ•°ï¼Œè¿™é‡Œæ˜¯é‡‡æ ·å¤©ç©ºç›’ï¼› $T(x)=\\frac{c}{\\pi}V(x,\\omega_i)max(0, nÂ·\\omega_i)$ï¼šä¼ è¾“é¡¹å‡½æ•°ï¼Œ$V(x,w_i)$ ï¼šå³visibilityï¼ŒæŒ‡é¡¶ç‚¹çš„å¯è§æ€§ï¼›$\\rho(w_i,w_o) $ï¼šæ˜¯BRDFé¡¹ï¼Œå› ä¸ºåªè€ƒè™‘æ¼«åå°„ï¼Œæ‰€ä»¥å¯ä»¥æå–ä¸ºå¸¸æ•°é¡¹$\\frac{c}{\\pi}$; â€‹ éœ€è¦åšçš„æ˜¯å°†$L(\\omega_i)$ã€$T(x)$è¿™ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«æŠ•å½±åˆ°çƒè°å‡½æ•°ä¸Šï¼Œå³æ±‚å‡ºå…¶å¯¹åº”ç³»æ•°å¹¶å­˜å‚¨åˆ°çŸ©é˜µé‡Œï¼Œåœ¨æ¸²æŸ“æ—¶ä½¿ç”¨ï¼Œä»è€ŒåŒ–ç§¯åˆ†ä¸ºç‚¹ä¹˜:$$L= \\sum_{i=0}^{n} L_i T_i$$ â€‹ ä½œä¸šä¸­ä½¿ç”¨çš„2ä¸ªçŸ©é˜µä¸ºï¼š m_LightCoeffs ï¼šè®°å½•ç¯å¢ƒå…‰çš„çƒè°ç³»æ•°ï¼Œä»¥rgbçš„å½¢å¼å­˜å‚¨ï¼Œæ˜¯å¤§å° 3 x (l + 1) ^ 2çš„çŸ©é˜µï¼Œæ¯åˆ—å­˜å‚¨æ¯ä¸ªç¯å¢ƒå…‰ç³»æ•°çš„rgbå€¼ï¼› m_TransportSHCoeffsï¼š è®°å½•ä¼ è¾“é¡¹ç³»æ•°ï¼Œæ˜¯å¤§å°(l + 1) ^ 2 x é¡¶ç‚¹æ•°é‡çš„çŸ©é˜µï¼Œ(i , j) å­˜å‚¨ç¬¬jä¸ªé¡¶ç‚¹çš„ç¬¬iä¸ªç³»æ•°ã€‚ 1. Project :1.1 è®¡ç®—ç¯å¢ƒå…‰ç³»æ•°â€‹ å‰æ–‡å·²çŸ¥ï¼ŒæŠ•å½±çš„è¿‡ç¨‹ã€å³æ±‚è¢«æŠ•å‡½æ•°*åŸºå‡½æ•°åœ¨åŸå‡½æ•°å®šä¹‰åŸŸä¸Šç§¯åˆ†çš„è¿‡ç¨‹ã€‚å¯¹äºä¸€ä¸ªå®šä¹‰åœ¨çƒåæ ‡ç³»ä¸Šçš„å‡½æ•°$f(\\theta,\\phi)$ï¼Œå…¶ç§¯åˆ†ä¸ºï¼š$\\int_0^{2\\pi}\\int_0^{\\pi}f(\\theta,\\phi)sin(\\theta)d\\theta d\\phi$ï¼Œå…¶ä¸­$sin(\\theta)$ç”¨äºå¹³è¡¡ä¸¤æåˆ°èµ¤é“çš„ä¸åŒå•ä½ç«‹ä½“è§’å¤§å°ã€‚ä½†æ˜¯å› ä¸ºè’™ç‰¹å¡æ´›ç§¯åˆ†çš„æ ·æœ¬æœ¬èº«æ˜¯æ— åçš„ï¼Œæ¯ä¸€ä¸ªæ ·æœ¬æœ‰ç›¸ç­‰çš„æ¦‚ç‡å¯†åº¦å‡½æ•°$\\frac{1}{4\\pi}$ï¼Œå› æ­¤åœ¨è¿™æ ·çš„æƒ…å†µä¸‹ï¼Œåº”ç”¨$4\\pi$ä»£æ›¿$sin(\\theta)$ã€‚æ‰€ä»¥æˆ‘ä»¬æœ‰ç¬¬iä¸ªç³»æ•°çš„ç¦»æ•£å…¬å¼ä¸ºï¼š$$C_i=\\frac{4\\pi}{N}\\sum_{i=1}^{N}L(x_j)Y_i(x_j)$$â€‹ ç¬¬ä¸€æ­¥éœ€è¦åœ¨PrecomputeCubemapSHå‡½æ•°å®Œæˆå¯¹ç¯å¢ƒå…‰ç³»æ•°çš„æ±‚è§£ï¼Œå¹¶å°†è¿”å›å€¼ä»¥RGBçš„å­˜å‚¨åœ¨çŸ©é˜µm_LightCoeffsé‡Œã€‚ 1auto envCoeffs = ProjEnv::PrecomputeCubemapSH&lt;SHOrder&gt;(images, width, height, channel); â€‹ EvalSH å‡½æ•°å³ $Y_l^m(\\theta, \\varphi)$ , è®¡ç®—æ¯ä¸ªå•ä½æ–¹å‘å‘é‡å¯¹åº”çš„åŸºå‡½æ•°å€¼ï¼š 1double EvalSH(int l, int m, const Eigen::Vector3d&amp; dir) â€‹ ç¬¬lé˜¶ã€ç¬¬mä¸ªç³»æ•°çš„å¯¹åº”æ•°ç»„åºå·å¯å‚è€ƒæºç é‡Œçš„GetIndexå‡½æ•°ï¼š 123constexpr int GetIndex(int l, int m) { return l * (l + 1) + m;} â€‹ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä½œä¸šæ¡†æ¶ä¸­ä½¿ç”¨çš„æ˜¯é»æ›¼å’Œæ–¹æ³•å¯¹ç¯å¢ƒå…‰æ±‚ç§¯åˆ†ï¼Œæƒé‡ä¸ºç«‹æ–¹ä½“è´´å›¾çš„å•ä¸ªçº¹ç´ æ‰€å¯¹åº”åœ¨çƒä½“ä¸Šçš„è¡¨é¢ç§¯ï¼š 1float CalcArea(const float &amp;u_, const float &amp;v_, const int &amp;width, const int &amp;height) 123456789for (int l = 0; l &lt; SHOrder; l++){ for (int m = -l; m &lt;= l; m++) { float sh = sh::EvalSH(l, m, dir.cast&lt;double&gt;().normalized()); float delta = CalcArea(x, y, width, height); SHCoeffiecents[l * (l + 1) + m] += Le * sh * delta; }} 1.2 è®¡ç®—ä¼ è¾“é¡¹ç³»æ•°â€‹ æ¯ä¸ªé¡¶ç‚¹çš„ä¼ è¾“é¡¹ç³»æ•°ï¼Œå®é™…è®°å½•ç€å…¶å¯ä»¥æ¥æ”¶åˆ°å¤šå°‘ç›´æ¥å’Œé—´æ¥å…‰ç…§ã€‚ â€‹ shFunc æ˜¯ä¼ è¾“é¡¹å‡½æ•°ï¼Œæ˜¯éœ€è¦è¢«æŠ•å½±åˆ°çƒè°å‡½æ•°ä¸Šçš„æ–¹ç¨‹ï¼Œä¹Ÿæ˜¯éœ€è¦æˆ‘ä»¬å®Œæˆçš„éƒ¨åˆ†ï¼Œç”±ç®€åˆ°ç¹ä¾æ¬¡æœ‰unshadowedã€shadowedå’Œinterreflectionä¸‰ç§ã€‚ 1234auto shCoeff = sh::ProjectFunction(SHOrder, shFunc, m_SampleCount);for (int j = 0; j &lt; shCoeff-&gt;size(); j++){ m_TransportSHCoeffs.col(i).coeffRef(j) = (*shCoeff)[j];} â€‹ æŠ•å½±å‡½æ•°sh::ProjectFunctionï¼š 12345// Fit the given analytical spherical function to the SH basis functions// up to @order. This uses Monte Carlo sampling to estimate the underlying// integral.std::unique_ptr&lt;std::vector&lt;double&gt;&gt; ProjectFunction( int order, const SphericalFunction&amp; func, int sample_count); â€‹ å¯¹äºå‰ä¸¤ç§æƒ…å†µï¼Œç¿»è¯‘å…¬å¼å¡«åˆ°shFuncé‡Œå°±è¡Œï¼›å› ä¸ºåªè€ƒè™‘æ¼«åå°„è¡¨é¢ï¼Œbrdfé¡¹å¯ä»¥ç®€åŒ–ä¸ºå¸¸é‡ï¼Œå› æ­¤ä¼ è¾“é¡¹ä¸ºï¼š$$L_{DS}(x)=\\frac{\\rho_x}{\\pi} \\int_{\\Omega}V(w_i) max(0, n_xÂ·w_i)dw_i$$â€‹ å› ä¸ºsh::ProjectFunctionä¸­åªæœ‰ç§¯åˆ†çš„å³åŠéƒ¨åˆ†ï¼Œæ‰€ä»¥æœ€ç»ˆç³»æ•°éœ€è¦è‡ªè¡Œé™¤ä»¥$\\pi$ã€‚ 12345678910111213if (m_Type == Type::Unshadowed){ // TODO: here you need to calculate unshadowed transport term of a given direction // TODO: æ­¤å¤„ä½ éœ€è¦è®¡ç®—ç»™å®šæ–¹å‘ä¸‹çš„unshadowedä¼ è¾“é¡¹çƒè°å‡½æ•°å€¼ return std::max(float(0.), wi.dot(n));}else{ // TODO: here you need to calculate shadowed transport term of a given direction // TODO: æ­¤å¤„ä½ éœ€è¦è®¡ç®—ç»™å®šæ–¹å‘ä¸‹çš„shadowedä¼ è¾“é¡¹çƒè°å‡½æ•°å€¼ double H = wi.dot(n); return (H &gt; 0 &amp;&amp; !(scene-&gt;rayIntersect(Ray3f(v, wi.normalized()))))? H : 0;} â€‹ è€Œè€ƒè™‘åˆ°å…‰çº¿å®é™…ä¼šåœ¨è¡¨é¢é—´äº’ç›¸å¼¹å°„ï¼ˆinterrelectionï¼‰ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå…¶ä»–ç€è‰²ç‚¹ä¼šæˆä¸ºæ¬¡çº§å…‰æºç…§äº®å½“å‰ç‚¹ï¼Œå› æ­¤ä¸€æ¬¡å¼¹å°„çš„å…¬å¼ï¼š$$L_{DI}(x)=L_{DS}+\\frac{\\rho_x}{\\pi} \\int_{\\Omega}\\overline{L}(xâ€™,w_i)(1-V(w_i)) max(0, n_xÂ·w_i)dw_i$$â€‹ åœ¨è®¡ç®—å‡ºå½“å‰é¡¶ç‚¹çš„Diffuse Shadowå€¼ä¹‹åï¼Œç”¨è’™ç‰¹å¡æ´›ç§¯åˆ†æ³•è¿›è¡Œé‡‡æ ·ï¼›å¯¹äºæ¯ä¸€ä¸ªæ ·æœ¬ï¼ˆå°„çº¿ï¼‰ï¼Œå¦‚æœä¸åœºæ™¯ä¸­çš„ç‰©ä½“æœ‰äº¤ç‚¹ï¼Œåˆ™å°†äº¤ç‚¹å¤„çš„ç³»æ•°å€¼è§†ä½œæ¬¡çº§å…‰æºï¼Œå¹¶è®¡ç®—å…¶å¯¹åŸé¡¶ç‚¹çš„è´¡çŒ®ã€‚è€Œè®¡ç®—äº¤ç‚¹å¤„çš„å€¼ï¼Œåˆ™éœ€è¦ç”¨ä¸‰è§’å½¢é‡å¿ƒçº¿æ€§æ’å€¼ä¸‰ä¸ªé¡¶ç‚¹çš„ç³»æ•°å³å¯ï¼Œè¿™ä¹Ÿæ˜¯å…¬å¼ä¸­$\\overline{L}(xâ€™)$çš„æ„ä¹‰ã€‚ â€‹ éå†å®Œæ‰€æœ‰é¡¶ç‚¹æ‰€å¾—çš„ä¸€ç»„æ–°çš„ç³»æ•°ï¼ˆå…¬å¼çš„å³åŠéƒ¨åˆ†ï¼‰ï¼Œæ­£æ˜¯ä¸‹ä¸€æ¬¡å¼¹å°„çš„åˆå§‹ç³»æ•°ï¼ˆå…¬å¼çš„å·¦åŠéƒ¨åˆ†ï¼‰ã€‚é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼Œç›´åˆ°å…‰ç…§æ”¶æ•›æˆ–åˆ°è¾¾è¿­ä»£æ¬¡æ•°ã€‚æœ€åå°†æ‰€æœ‰å¼¹å°„æ‰€å¾—ç³»æ•°ç´¯åŠ è‡³åŸä¼ è¾“é¡¹ç³»æ•°ä¸Šã€‚ Global illumination and radiosity programmers will recognize this is a probabilistic gathering solution, where each point on the model blindly searches for neighbors that can see it and drags in light from the outside world, with the effect that the model is slowly lit by completely solving one lighting point at a time. â€‹ å› ä¸ºå½¢å¼ä¸Šçš„ç›¸è¿‘ï¼Œå¯ä»¥é­”æ”¹sh::ProjectFunctionå‡½æ•°ã€‚æ³¨æ„9ä¸ªç³»æ•°åˆ†åˆ«å¯¹åº”ä¸åŒçš„å€¼ã€‚ å¦‚æœè€ƒè™‘ç‰©ä½“æœ¬èº«çš„é¢œè‰²æˆ–åœºæ™¯ä¸­å®é™…æœ‰å¤šä¸ªç‰©ä½“ï¼ŒLé¡¹ç³»æ•°ä¹Ÿéœ€è¦è®¡ç®—ï¼Œè¿™é‡Œåªè®¡ç®—äº†Té¡¹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (m_Type == Type::Interreflection) { std::vector&lt;Eigen::MatrixXf&gt; transportSHCoeffs(m_Bounce, Eigen::MatrixXf(SHCoeffLength, mesh-&gt;getVertexCount())); for (int bounce = 0; bounce &lt; m_Bounce; bounce++) { for (int i = 0; i &lt; mesh-&gt;getVertexCount(); i++) { Point3f v = mesh-&gt;getVertexPositions().col(i); const Normal3f &amp;n = mesh-&gt;getVertexNormals().col(i); auto shFunc = [&amp;](double phi, double theta) -&gt; std::vector&lt;double&gt; { Eigen::Array3d d = sh::ToVector(phi, theta); auto wi = Vector3f(d.x(), d.y(), d.z()).normalized(); Intersection its; std::vector&lt;double&gt; res(SHCoeffLength, 0); auto H = wi.dot(n); if (H &gt; 0 &amp;&amp; scene-&gt;rayIntersect(Ray3f(v, wi), its)) { const Vector3f &amp;bary = its.bary; for (int j = 0; j &lt; SHCoeffLength; j++) { auto its_x = its.tri_index.x(); auto its_y = its.tri_index.y(); auto its_z = its.tri_index.z(); Vector3f sh = (bounce &gt; 0) ? Vector3f(transportSHCoeffs[bounce - 1].col(its_x).coeffRef(j), transportSHCoeffs[bounce - 1].col(its_y).coeffRef(j), transportSHCoeffs[bounce - 1].col(its_z).coeffRef(j)) : Vector3f(m_TransportSHCoeffs.col(its_x).coeffRef(j), m_TransportSHCoeffs.col(its_y).coeffRef(j), m_TransportSHCoeffs.col(its_z).coeffRef(j)); auto indirectSH = bary.dot(sh); res[j] = indirectSH * H; } } return res; }; auto shCoeff = sh::ProjectFunctionCustom(SHOrder, shFunc, m_SampleCount); for (int j = 0; j &lt; shCoeff-&gt;size(); j++) { transportSHCoeffs[bounce].col(i).coeffRef(j) = (*shCoeff)[j] / M_PI; // ç´¯åŠ  m_TransportSHCoeffs.col(i).coeffRef(j) += transportSHCoeffs[bounce].col(i).coeffRef(j); } } } } The assumption here is that illumination doesnâ€™t vary across the model (i.e. point B has exactly the same lighting function as point A). This is the key to SH lighting: Low frequency light sources and very small light source variance across an object. å·¦shadowedï¼Œå³interreflection = 5 â€‹ ä¼¼ä¹è·Ÿä½œä¸šæ–‡æ¡£æœ‰åˆ†æ­§ï¼ˆç®—äº†æ”¶æ•›äº†å°±è¡Œï¼‰ 2. Reconstructâ€‹ ç›´æ¥ç¿»è¯‘å…¬å¼3ï¼Œåœ¨vertex shaderé‡Œè®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„é¢œè‰²ï¼Œç»æ’å€¼åä¼ é€’ç»™fragment shaderå³å¯ã€‚ 1234567891011121314151617attribute mat3 aPrecomputeLT;uniform mat3 uPrecomputeLR;uniform mat3 uPrecomputeLG;uniform mat3 uPrecomputeLB;varying vec3 vColor;void main(void) { vColor = vec3(0.0); for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ vColor += aPrecomputeLT[i][j] * vec3(uPrecomputeLR[i][j], uPrecomputeLG[i][j], uPrecomputeLB[i][j]); } } gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);} å·¦shadowedï¼›å³interreflectionï¼Œå…¶self-shadowç¨äº® 3. æ—‹è½¬â€‹ prtä¸­è™½ç„¶è¦æ±‚åœºæ™¯æ˜¯é™æ€çš„ï¼Œä½†ç”±äºçƒè°å‡½æ•°å…·æœ‰æ—‹è½¬ä¸å˜æ€§ï¼Œæ‰€ä»¥å…‰æºå¯ä»¥æ—‹è½¬ã€‚æ ¹æ®æ–‡æ¡£ç»™å‡ºçš„å…¬å¼ç¿»è¯‘æˆä»£ç ï¼Œå¡«åˆ°tools.jsæ–‡ä»¶ä¸­å¯¹åº”çš„åœ°æ–¹ã€‚ â€‹ **glslçš„çŸ©é˜µæ˜¯åˆ—ä¸»åºï¼Œmat[i][j]è¡¨ç¤ºç¬¬iåˆ—ã€ç¬¬jè¡Œçš„å€¼ï¼Œä½†æ˜¯math.size(i, j)ã€jsæ•°ç»„éƒ½æ˜¯è¡Œä¸»åºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function getRotationPrecomputeL(precompute_L, rotationMatrix) { let mat3 = computeSquareMatrix_3by3(rotationMatrix); let mat5 = computeSquareMatrix_5by5(rotationMatrix); let result = []; for (let i = 0; i &lt; 3; i++) { let res = math.multiply(mat3, [precompute_L[i][1], precompute_L[i][2], precompute_L[i][3]])._data; let res5 = math.multiply(mat5, [precompute_L[i][4], precompute_L[i][5], precompute_L[i][6], precompute_L[i][6], precompute_L[i][8]])._data; result.push([precompute_L[i][0], res[0], res[1], res[2], res5[0], res5[1], res5[2], res5[3], res5[4]]); } return result;}function computeSquareMatrix_3by3(rotationMatrix) { // è®¡ç®—æ–¹é˜µSA(-1) 3*3 // 1ã€pick ni - {ni} // å¯¹äºç¬¬ l å±‚ bandï¼Œé€‰å– 2l + 1 ä¸ª normal vector n let n1 = [1, 0, 0, 0]; let n2 = [0, 0, 1, 0]; let n3 = [0, 1, 0, 0]; let normals = [n1, n2, n3]; let A = math.zeros(3, 3); let S = math.zeros(3, 3); let A_inverse = math.zeros(3, 3); // let rotationMatrix_trans = math.transpose(mat4Matrix2mathMatrix(rotationMatrix)); // æ•°åˆ—è½¬æ¢ä¸ºmath.mat let rotationMatrix_trans = (mat4Matrix2mathMatrix(rotationMatrix)); // æ•°åˆ—è½¬æ¢ä¸ºmath.mat // 2ã€{P(ni)} - A A_inverse // è®¡ç®—(2l + 1)ä¸ªnå„è‡ªåœ¨çƒè°ä¸Šçš„æŠ•å½±ï¼Œæ¯ä¸ªæœ‰(2l + 1)ä¸ªç³»æ•°ï¼Œæ„æˆ(2l + 1) * (2l + 1)çš„çŸ©é˜µAï¼Œå¹¶æ±‚å…¶é€†çŸ©é˜µ for (let i = 0; i &lt; 3; i++) { let proj = SHEval3(normals[i][0], normals[i][1], normals[i][2]); for (let j = 1; j &lt; 4; j++) A.set([j - 1, i], proj[j]);// iè¡Œjåˆ— } A_inverse = math.inv(A); // 3ã€ç”¨ R æ—‹è½¬ ni - {R(ni)} // 4ã€R(ni) SHæŠ•å½± - S // ç”¨è¾“å…¥çš„æ—‹è½¬çŸ©é˜µæ—‹è½¬niï¼Œå¹¶å°†ç»“æœæŠ•å½±ï¼Œç±»ä¼¼æ­¥éª¤2ï¼Œå¾—åˆ°(2l + 1) * (2l + 1)çš„çŸ©é˜µS for (let i = 0; i &lt; 3; i++) { //let vec = math.matrix([normals[i][0], normals[i][1], normals[i][2], 0]); // col vector //let n = math.multiply(rotationMatrix_trans, vec)._data;// (4 * 4) * (4 * 1) ç¬¬ä¸€ä¸ªåˆ—æ•°ç­‰äºç¬¬äºŒä¸ªè¡Œæ•° let n = vec4.create(); vec4.transformMat4(n, normals[i], rotationMatrix); let proj = SHEval3(n[0], n[1], n[2]); for (let j = 1; j &lt; 4; j++) S.set([j - 1, i], proj[j]); } // 5ã€S*A_inverse return math.multiply(S, A_inverse);} ğŸ”§å·¥å…·ï¼š Glsl: https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.30.pdf#page=35 Webgl: https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html ide debug: https://code.visualstudio.com/docs/cpp/launch-json-reference","link":"/2023/02/05/Games202-2_hmw/"},{"title":"äººç”Ÿè´µåœ¨æŠ˜è…¾(â‰§â–½â‰¦)","text":"","link":"/2023/02/04/test/"}],"tags":[{"name":"å›¾å½¢å­¦","slug":"å›¾å½¢å­¦","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"categories":[],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}