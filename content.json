{"posts":[{"title":"Games202-2 实时环境光照","text":"1.IBL1.0先简单盘一下数学： 概率密度函数：其积分值=定义域内的概率值，$\\int_{-\\infin}^{+\\infin}f(x)dx=1$ 期望：每次可能的结果乘以其结果概率的总和，描述了随机变量的平均值 方差：随机变量离期望的距离，描述了随机变量的离散程度 大数定律：当样本数量足够大时，事件发生的频率收敛于概率。如：为了计算一个国家所有公民的平均身高，可以选择一个完全随机（无偏）的人口子集，测量他们的身高并对结果求平均，即用均值近似求解概率。 蒙特卡罗积分：$\\int_{a}^{b}f(x)dx\\approx \\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{f(x)}{pdf(x)}$ pdf值更高的样本被选取的可能性更大，即某些样本可能比其他样本具有更高的生成概率，所以要除以或乘以pdf以平衡，可以看作是一个权重。如：在单位球体表面$\\Omega$生成N个随机采样，权衡每个样本对结果的贡献并求和。由球体表面积公式，这种情况下、每个样本可能性$p(x_i)=\\frac{1}{4\\pi}$，因此权重$\\omega_i=\\frac{1}{p(x_i)}=4\\pi$。 低差异序列：随机样本，但样本分布更均匀 分层采样：为了降低样本的方差，划分单元，每个单元内生成一个随机样本 重要性采样：已知pdf函数的分布信息生成采样向量。 1.1 Diffuse​ 我们知道天空盒可以模拟遥远的环境光，在早期的实践中，人们会用反射或折射向量采样天空盒纹理作为物体表面颜色，以模拟环境光源对着色的影响，这一技术被称为环境贴图。而随着渲染模型的升级，简单环境贴图显然不能满足需要，基于图像的光照（image based lighting）应运而生。 ​ 渲染方程（不考虑阴影）：$$L_o(p, \\omega_o)=\\int_{\\Omega}(k_d\\frac{c}{\\pi}+k_s\\frac{DFG}{4(\\omega_o·n)(\\omega_i·n)})L_i(p,\\omega_i)n·\\omega_id\\omega_i$$​ 可以拆分为漫反射和镜面两部分，其中漫反射部分为：$$L_o(p, \\omega_o)=k_d\\frac{c}{\\pi}\\int_{\\Omega}L_i(p,\\omega_i)n·\\omega_id\\omega_i$$ ​ Lambert的漫反射项是一个常数，因此需要对来自四面八方的环境光计算均值，并用顶点法线查询。对于每一个可能的采样方向n，s在半球表面均匀生成样本求平均。遍历采样方向，可以遍历$\\theta$, $\\phi$，并转换成方向向量：$$\\begin{cases} x=rsin\\theta cos\\phi\\ y=rsin\\theta cos\\phi\\ z=rcos\\phi\\end{cases}$$​ 也可以直接渲染一个位于原点的单位立方体，用归一化后的本地坐标采样。 ​ 关于样本的生成，可以用蒙特卡洛积分法，这里使用的是黎曼和法。公式2的离散版本：$$L_o(p,\\phi,\\theta)=K_d\\frac{c}{\\pi}\\frac{1}{n_1n_2}\\sum_{\\phi=0}^{n_1}\\sum_{\\theta=0}^{n_2}L_i(p,\\phi_i,\\theta_i)cos(\\theta)sin(\\theta)d\\theta d\\phi$$​ 其中，立体角公式：$\\Omega=\\frac{dA}{r^2}=sin(\\theta)d\\theta d\\phi$，$sin(\\theta)$也可以理解成是用来平衡球体两极位置的采样区域（patches )较小而赤道处较大的形状。 ​ 因为取平均的方法丢失了光照的大部分高频细节，因此纹理分辨率无需太高。 1.2 Specular​ 分割求和近似法（split sum approximation）将镜面反射积分拆成两个独立的积分：$$L_o(p, \\omega_o)=\\int_{\\Omega}L_i(p,\\omega_i)d\\omega_i * \\int_{\\Omega}k_sf_r(\\omega_o,\\omega_i)n·\\omega_id _{\\omega_i}$$ 1.2.1 预滤波贴图​ 积分的第一部分，类似漫反射辐照度贴图，但需要将粗糙度纳入考虑范围。不同于lambert平面的均匀反射，glossy物体表面的镜面反射光的形状取决于表面的粗糙。所有可能的反射光线会形成一个specular lobe，围绕着反射向量R，表面越粗糙，反射越分散。因此均匀采样会导致无效采样。 ​ GGX重要性采样会根据粗糙度，将微表面的半程向量偏向其宏观反射方向，即向着反射向量“聚集”，使其分布限制在lobe内。根据lobe的形状决定样本覆盖的范围，在实时端用镜面反射R查询： ​ 理论上来说粗糙度越高，反射越模糊。可以在0到1间取几个锚点，生成对应的贴图，为了方便使用，可生成数个级别的mipmap，并用粗糙度线性插值。 1.2.2 BRDF积分贴图​ 对于第二部分brdf公式，有3个变量$\\omega_i、w_o$、粗糙度和基础反射率$F_0$，为了减少变量数，需要对方程进行一些变形。 ​ brdf中的菲涅尔项公式为：$$F(h,\\omega_o)=F_0+(1-F_0)(1-cos\\theta)^5\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad =F_0(1-(1-cos\\theta)^5)+ (1-cos\\theta)^5$$ ​ 第二部分分子分母同乘菲涅尔项：$$L_o(p, \\omega_o)=\\int_{\\Omega}\\frac{f_r(\\omega_o,\\omega_i,r)}{F(h,\\omega_0)}F(h,\\omega_0)n·\\omega_id _{\\omega_i}$$ ​ 代入公式6，并将积分拆成两项：$$F_0\\int_{\\Omega} \\frac{f_r(\\omega_o,\\omega_i,r)}{F(h,\\omega_0)}(1-(1-cos\\theta)^5)n·\\omega_id_{\\omega_i} +\\int_{\\Omega} \\frac{f_r(\\omega_o,\\omega_i,r)}{F(h,\\omega_0)}(1-cos\\theta)^5n·\\omega_id_{\\omega_i}$$ ​ 其中$fr$的分母包含F项，约分后有：$$F_0\\int_{\\Omega}f_r(\\omega_o,\\omega_i,r)(1-(1-cos\\theta)^5)n·\\omega_id_{\\omega_i}+\\int_{\\Omega}f_r(\\omega_o,\\omega_i,r)(1-cos\\theta)^5n·\\omega_id_{\\omega_i}$$​ $F_0$被提取到积分之外，所以最终只需要计算2个变量$(roughness,\\theta)$的可能性组合。因此，我们可以以$co s\\theta$为横坐标，粗糙度为纵坐标，R、G通道各存放一个预计算值，得到这样一张查找表： ​ 以上是建立在环境光源无限远的假设上，场景中的各个点所接收到的辐照度是相同的，即无视render point 位置，但在室内这样环境光分布差异较大的场景就会显得不真实，引擎中通常在场景中放置多个反射探针，实时计算时插值。 2. Spherical Harmonic基函数：一组简单信号，可以通过线性变换（缩放、相加）生成原函数的近似。 投影：计算出每一个基函数权重值的过程。这一标量描述了原函数$f(x)$有多接近每一个基函数$B_i(x)$。计算每一个权重的过程，就是在f的定义域上计算$f(x)B_i(x)$的积分：$$c_i=\\int_{\\Omega}f(\\omega)B_i(\\omega)d\\omega$$重建：类似卷积的过程，用每一个基函数乘以其对应权重、并累加的结果去近似原函数。 投影和重建的过程 虚线：原函数；实线：近似函数 球谐函数：可以视作三维空间对二维平面fourier变换的类比： 使用球谐函数的近似，可以看到阶数越高越接近原函数 ​ 基函数数量决定还原的精确度，低阶通常会损失高频信息。引擎中常用的是9阶（l = 9）球谐函数，工作方法类似一个低通滤波器（只通过低频信息），符合环境-漫反射辐照度的特点；此外，重建的过程将积分降为点乘，在现代GPU架构上极大地提高了效率。 佬の鄙夷 3.PRT​ 如果需要将阴影和brdf项也纳入考虑范围，需要在每点分布生成3张贴图，所需内存过多。 ​ precomputed radiance transfer则可以看作是上述方案的一个平替。其基本思想是将渲染方程拆成光照和传输两项，分别投影到球谐函数上，并在实时端重建光照。其前提和限制是，假设场景中的物体和视角都保持不变，只有光源变化（可旋转，旋转光源相当于旋转任意一个基函数）。 3.1 Diffuse​ 光照方程：$$L(o) = \\int_{\\Omega}\\textcolor{}{L(i)}\\textcolor{}{V(i)\\rho(i,o) max(0, n·i)}d_i$$​ 由前文，光照函数可以表示为：$$L(i)\\approx \\sum l_iB_i(i)$$​ 代入原式、并交换积分求和顺序，有：$$L(o) \\approx \\sum l_i \\int_{\\Omega}\\textcolor{Crimson}{B_i(i)}\\textcolor{Teal}{V(i)\\rho(i,o) max(0, n·i)}d_i$$​ 可以看到积分的右半部分也可以视作是基函数 * 一个被投影函数的形式，这一函数即传输函数$T(i)$，所以有求传输项系数的方法为：$$T_i\\approx \\int_{\\Omega}B_i(i)V(i)max(0,n ·i)di$$ ​ 在实时端，将两个系数相乘并累加，近似原光照，从而将积分的过程降为点乘：$$L_o\\approx \\rho \\sum l_i T_i$$ ​ 对于lambert材质，视线无关，brdf可以提取为常数项，用$\\rho$表示。 3.2 Specular​ 对于glossy材质，brdf不再是常数，而是2个方向的4维函数$\\rho(\\omega_i,\\omega_o)$，需要计算视线和光线的组合。前文已将传输函数投影到入射方向： $$L(o)\\approx \\sum L_iT_i(o)$$ ​ 将投影后的结果，再一次投影到出射方向上：$$T_i(o)\\approx \\sum t_{ij}B_j(o)$$​ 代入公式16，最终有：$$L(o)\\approx \\sum (\\sum l_it_{ij})B_j(o)$$​ 即以光照系数乘传输系数矩阵，如下图： ​ 以上涉及到矩阵运算、其运算复杂度增加；对于特别glossy的物体，低阶球谐的应用性有限。 ​ 低阶球谐，相比于预滤波辐照度贴图，具有较好地还原低频（漫反射）环境光和（软）阴影、省内存、运算效率高的优点；但是因为毕竟只能还原低频信息，如需表现镜面反射，需要结合其他手段，比如镜面贴图。 精选弹幕 🦄️： 课件： https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_05.pdf https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES202_Lecture_06.pdf PRT阅读材料： https://www.cse.chalmers.se/~uffe/xjobb/Readings/GlobalIllumination/Spherical%20Harmonic%20Lighting%20-%20the%20gritty%20details.pdf https://cseweb.ucsd.edu/~ravir/prtsurvey.pdf IBL: https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/ 第一部分的数学： https://zhuanlan.zhihu.com/p/146144853 https://zhuanlan.zhihu.com/p/365624460","link":"/2023/02/05/Games202-2/"},{"title":"Games202 作业2","text":"0.$$L(\\omega_o) = \\int_{\\Omega}L(\\omega_i)V(\\omega_i)\\rho(\\omega_i,\\omega_o) max(0, n·\\omega_i)d\\omega_i$$ $L(\\omega_i)$：光照函数，这里是采样天空盒； $T(x)=\\frac{c}{\\pi}V(x,\\omega_i)max(0, n·\\omega_i)$：传输项函数，$V(x,w_i)$ ：即visibility，指顶点的可见性；$\\rho(w_i,w_o) $：是BRDF项，因为只考虑漫反射，所以可以提取为常数项$\\frac{c}{\\pi}$; ​ 需要做的是将$L(\\omega_i)$、$T(x)$这两个函数分别投影到球谐函数上，即求出其对应系数并存储到矩阵里，在渲染时使用，从而化积分为点乘:$$L= \\sum_{i=0}^{n} L_i T_i$$ ​ 作业中使用的2个矩阵为： m_LightCoeffs ：记录环境光的球谐系数，以rgb的形式存储，是大小 3 x (l + 1) ^ 2的矩阵，每列存储每个环境光系数的rgb值； m_TransportSHCoeffs： 记录传输项系数，是大小(l + 1) ^ 2 x 顶点数量的矩阵，(i , j) 存储第j个顶点的第i个系数。 1. Project :1.1 计算环境光系数​ 前文已知，投影的过程、即求被投函数*基函数在原函数定义域上积分的过程。对于一个定义在球坐标系上的函数$f(\\theta,\\phi)$，其积分为：$\\int_0^{2\\pi}\\int_0^{\\pi}f(\\theta,\\phi)sin(\\theta)d\\theta d\\phi$，其中$sin(\\theta)$用于平衡两极到赤道的不同单位立体角大小。但是因为蒙特卡洛积分的样本本身是无偏的，每一个样本有相等的概率密度函数$\\frac{1}{4\\pi}$，因此在这样的情况下，应用$4\\pi$代替$sin(\\theta)$。所以我们有第i个系数的离散公式为：$$C_i=\\frac{4\\pi}{N}\\sum_{i=1}^{N}L(x_j)Y_i(x_j)$$​ 第一步需要在PrecomputeCubemapSH函数完成对环境光系数的求解，并将返回值以RGB的存储在矩阵m_LightCoeffs里。 1auto envCoeffs = ProjEnv::PrecomputeCubemapSH&lt;SHOrder&gt;(images, width, height, channel); ​ EvalSH 函数即 $Y_l^m(\\theta, \\varphi)$ , 计算每个单位方向向量对应的基函数值： 1double EvalSH(int l, int m, const Eigen::Vector3d&amp; dir) ​ 第l阶、第m个系数的对应数组序号可参考源码里的GetIndex函数： 123constexpr int GetIndex(int l, int m) { return l * (l + 1) + m;} ​ 需要注意的是，在作业框架中使用的是黎曼和方法对环境光求积分，权重为立方体贴图的单个纹素所对应在球体上的表面积： 1float CalcArea(const float &amp;u_, const float &amp;v_, const int &amp;width, const int &amp;height) 123456789for (int l = 0; l &lt; SHOrder; l++){ for (int m = -l; m &lt;= l; m++) { float sh = sh::EvalSH(l, m, dir.cast&lt;double&gt;().normalized()); float delta = CalcArea(x, y, width, height); SHCoeffiecents[l * (l + 1) + m] += Le * sh * delta; }} 1.2 计算传输项系数​ 每个顶点的传输项系数，实际记录着其可以接收到多少直接和间接光照。 ​ shFunc 是传输项函数，是需要被投影到球谐函数上的方程，也是需要我们完成的部分，由简到繁依次有unshadowed、shadowed和interreflection三种。 1234auto shCoeff = sh::ProjectFunction(SHOrder, shFunc, m_SampleCount);for (int j = 0; j &lt; shCoeff-&gt;size(); j++){ m_TransportSHCoeffs.col(i).coeffRef(j) = (*shCoeff)[j];} ​ 投影函数sh::ProjectFunction： 12345// Fit the given analytical spherical function to the SH basis functions// up to @order. This uses Monte Carlo sampling to estimate the underlying// integral.std::unique_ptr&lt;std::vector&lt;double&gt;&gt; ProjectFunction( int order, const SphericalFunction&amp; func, int sample_count); ​ 对于前两种情况，翻译公式填到shFunc里就行；因为只考虑漫反射表面，brdf项可以简化为常量，因此传输项为：$$L_{DS}(x)=\\frac{\\rho_x}{\\pi} \\int_{\\Omega}V(w_i) max(0, n_x·w_i)dw_i$$​ 因为sh::ProjectFunction中只有积分的右半部分，所以最终系数需要自行除以$\\pi$。 12345678910111213if (m_Type == Type::Unshadowed){ // TODO: here you need to calculate unshadowed transport term of a given direction // TODO: 此处你需要计算给定方向下的unshadowed传输项球谐函数值 return std::max(float(0.), wi.dot(n));}else{ // TODO: here you need to calculate shadowed transport term of a given direction // TODO: 此处你需要计算给定方向下的shadowed传输项球谐函数值 double H = wi.dot(n); return (H &gt; 0 &amp;&amp; !(scene-&gt;rayIntersect(Ray3f(v, wi.normalized()))))? H : 0;} ​ 而考虑到光线实际会在表面间互相弹射（interrelection），在这种情况下，其他着色点会成为次级光源照亮当前点，因此一次弹射的公式：$$L_{DI}(x)=L_{DS}+\\frac{\\rho_x}{\\pi} \\int_{\\Omega}\\overline{L}(x’,w_i)(1-V(w_i)) max(0, n_x·w_i)dw_i$$​ 在计算出当前顶点的Diffuse Shadow值之后，用蒙特卡洛积分法进行采样；对于每一个样本（射线），如果与场景中的物体有交点，则将交点处的系数值视作次级光源，并计算其对原顶点的贡献。而计算交点处的值，则需要用三角形重心线性插值三个顶点的系数即可，这也是公式中$\\overline{L}(x’)$的意义。 ​ 遍历完所有顶点所得的一组新的系数（公式的右半部分），正是下一次弹射的初始系数（公式的左半部分）。重复以上步骤，直到光照收敛或到达迭代次数。最后将所有弹射所得系数累加至原传输项系数上。 Global illumination and radiosity programmers will recognize this is a probabilistic gathering solution, where each point on the model blindly searches for neighbors that can see it and drags in light from the outside world, with the effect that the model is slowly lit by completely solving one lighting point at a time. ​ 因为形式上的相近，可以魔改sh::ProjectFunction函数。注意9个系数分别对应不同的值。 如果考虑物体本身的颜色或场景中实际有多个物体，L项系数也需要计算，这里只计算了T项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (m_Type == Type::Interreflection) { std::vector&lt;Eigen::MatrixXf&gt; transportSHCoeffs(m_Bounce, Eigen::MatrixXf(SHCoeffLength, mesh-&gt;getVertexCount())); for (int bounce = 0; bounce &lt; m_Bounce; bounce++) { for (int i = 0; i &lt; mesh-&gt;getVertexCount(); i++) { Point3f v = mesh-&gt;getVertexPositions().col(i); const Normal3f &amp;n = mesh-&gt;getVertexNormals().col(i); auto shFunc = [&amp;](double phi, double theta) -&gt; std::vector&lt;double&gt; { Eigen::Array3d d = sh::ToVector(phi, theta); auto wi = Vector3f(d.x(), d.y(), d.z()).normalized(); Intersection its; std::vector&lt;double&gt; res(SHCoeffLength, 0); auto H = wi.dot(n); if (H &gt; 0 &amp;&amp; scene-&gt;rayIntersect(Ray3f(v, wi), its)) { const Vector3f &amp;bary = its.bary; for (int j = 0; j &lt; SHCoeffLength; j++) { auto its_x = its.tri_index.x(); auto its_y = its.tri_index.y(); auto its_z = its.tri_index.z(); Vector3f sh = (bounce &gt; 0) ? Vector3f(transportSHCoeffs[bounce - 1].col(its_x).coeffRef(j), transportSHCoeffs[bounce - 1].col(its_y).coeffRef(j), transportSHCoeffs[bounce - 1].col(its_z).coeffRef(j)) : Vector3f(m_TransportSHCoeffs.col(its_x).coeffRef(j), m_TransportSHCoeffs.col(its_y).coeffRef(j), m_TransportSHCoeffs.col(its_z).coeffRef(j)); auto indirectSH = bary.dot(sh); res[j] = indirectSH * H; } } return res; }; auto shCoeff = sh::ProjectFunctionCustom(SHOrder, shFunc, m_SampleCount); for (int j = 0; j &lt; shCoeff-&gt;size(); j++) { transportSHCoeffs[bounce].col(i).coeffRef(j) = (*shCoeff)[j] / M_PI; // 累加 m_TransportSHCoeffs.col(i).coeffRef(j) += transportSHCoeffs[bounce].col(i).coeffRef(j); } } } } The assumption here is that illumination doesn’t vary across the model (i.e. point B has exactly the same lighting function as point A). This is the key to SH lighting: Low frequency light sources and very small light source variance across an object. 左shadowed，右interreflection = 5 ​ 似乎跟作业文档有分歧（算了收敛了就行） 2. Reconstruct​ 直接翻译公式3，在vertex shader里计算每个顶点的颜色，经插值后传递给fragment shader即可。 1234567891011121314151617attribute mat3 aPrecomputeLT;uniform mat3 uPrecomputeLR;uniform mat3 uPrecomputeLG;uniform mat3 uPrecomputeLB;varying vec3 vColor;void main(void) { vColor = vec3(0.0); for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ vColor += aPrecomputeLT[i][j] * vec3(uPrecomputeLR[i][j], uPrecomputeLG[i][j], uPrecomputeLB[i][j]); } } gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);} 左shadowed；右interreflection，其self-shadow稍亮 3. 旋转​ prt中虽然要求场景是静态的，但由于球谐函数具有旋转不变性，所以光源可以旋转。根据文档给出的公式翻译成代码，填到tools.js文件中对应的地方。 ​ **glsl的矩阵是列主序，mat[i][j]表示第i列、第j行的值，但是math.size(i, j)、js数组都是行主序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function getRotationPrecomputeL(precompute_L, rotationMatrix) { let mat3 = computeSquareMatrix_3by3(rotationMatrix); let mat5 = computeSquareMatrix_5by5(rotationMatrix); let result = []; for (let i = 0; i &lt; 3; i++) { let res = math.multiply(mat3, [precompute_L[i][1], precompute_L[i][2], precompute_L[i][3]])._data; let res5 = math.multiply(mat5, [precompute_L[i][4], precompute_L[i][5], precompute_L[i][6], precompute_L[i][6], precompute_L[i][8]])._data; result.push([precompute_L[i][0], res[0], res[1], res[2], res5[0], res5[1], res5[2], res5[3], res5[4]]); } return result;}function computeSquareMatrix_3by3(rotationMatrix) { // 计算方阵SA(-1) 3*3 // 1、pick ni - {ni} // 对于第 l 层 band，选取 2l + 1 个 normal vector n let n1 = [1, 0, 0, 0]; let n2 = [0, 0, 1, 0]; let n3 = [0, 1, 0, 0]; let normals = [n1, n2, n3]; let A = math.zeros(3, 3); let S = math.zeros(3, 3); let A_inverse = math.zeros(3, 3); // let rotationMatrix_trans = math.transpose(mat4Matrix2mathMatrix(rotationMatrix)); // 数列转换为math.mat let rotationMatrix_trans = (mat4Matrix2mathMatrix(rotationMatrix)); // 数列转换为math.mat // 2、{P(ni)} - A A_inverse // 计算(2l + 1)个n各自在球谐上的投影，每个有(2l + 1)个系数，构成(2l + 1) * (2l + 1)的矩阵A，并求其逆矩阵 for (let i = 0; i &lt; 3; i++) { let proj = SHEval3(normals[i][0], normals[i][1], normals[i][2]); for (let j = 1; j &lt; 4; j++) A.set([j - 1, i], proj[j]);// i行j列 } A_inverse = math.inv(A); // 3、用 R 旋转 ni - {R(ni)} // 4、R(ni) SH投影 - S // 用输入的旋转矩阵旋转ni，并将结果投影，类似步骤2，得到(2l + 1) * (2l + 1)的矩阵S for (let i = 0; i &lt; 3; i++) { //let vec = math.matrix([normals[i][0], normals[i][1], normals[i][2], 0]); // col vector //let n = math.multiply(rotationMatrix_trans, vec)._data;// (4 * 4) * (4 * 1) 第一个列数等于第二个行数 let n = vec4.create(); vec4.transformMat4(n, normals[i], rotationMatrix); let proj = SHEval3(n[0], n[1], n[2]); for (let j = 1; j &lt; 4; j++) S.set([j - 1, i], proj[j]); } // 5、S*A_inverse return math.multiply(S, A_inverse);} 🔧工具： Glsl: https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.30.pdf#page=35 Webgl: https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html ide debug: https://code.visualstudio.com/docs/cpp/launch-json-reference","link":"/2023/02/05/Games202-2_hmw/"},{"title":"人生贵在折腾(≧▽≦)","text":"","link":"/2023/02/04/test/"}],"tags":[{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"categories":[],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}